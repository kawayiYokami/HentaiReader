# Agent 调试原则

## 🔍 **核心原则：先测试，后修复**

### **重要提醒**
> **以后为了检查问题在哪里，你可以每一步都写一个简单的测试文件检验一下，测完记得删掉。**
> **在测试和调试过程中，请优先使用项目提供的日志模块 [`utils.manga_logger`](utils/manga_logger.py) 进行信息输出，而不是直接使用 `print()`。**

### **调试流程**

#### **1. 问题发现阶段**
- ❌ **不要盲猜**：不要基于假设来修复问题
- ✅ **先观察**：通过测试文件输出实际的数据结构，使用 [`utils.manga_logger`](utils/manga_logger.py) 记录详细信息。
- ✅ **记录现象**：详细记录错误信息、异常行为以及相关的日志输出。

#### **2. 数据结构验证**
- 📝 **创建测试文件**：写简单的Python脚本验证数据结构。
- 🪵 **使用日志记录**：在测试脚本中，从 `utils.manga_logger` 导入 `debug`, `info`, `warning`, `error` 等函数进行输出。
  - `info(f"数据类型: {type(data)}")`
  - `debug(f"详细数据内容: {data}")` (注意：对于大数据结构，考虑分部分记录或记录摘要)
  - `info(f"字段列表: {list(data.keys())}")` (如果是字典)
  - `debug(f"字段 '{key}' 类型: {type(value)}")` (逐个检查)
- 🔍 **利用日志级别**：
  - 使用 `info()` 记录关键的检查点和摘要信息。
  - 使用 `debug()` 记录详细的变量值、中间状态等，这些信息在配置为 DEBUG 日志级别时才会显示。

#### **3. API调用测试**
- 🌐 **直接调用API**：使用curl或Python requests测试。
- 📊 **检查响应**：使用 [`utils.manga_logger`](utils/manga_logger.py) 记录API的请求参数、响应状态码、响应头和响应体。
  - `info(f"请求URL: {url}")`
  - `debug(f"请求参数: {params}")`
  - `info(f"响应状态码: {response.status_code}")`
  - `debug(f"响应内容: {response.text}")`
- 🔗 **追踪数据流**：从数据源到API响应的完整路径，关键节点使用日志记录。

#### **4. 逐步验证修复**
- 🧪 **小步测试**：每修改一个地方就测试一次。
- ✅ **验证假设**：确认修复方向是正确的，通过日志输出验证修改效果。
- 🔄 **迭代改进**：基于测试结果和日志信息调整修复策略。

#### **5. 清理工作**
- 🗑️ **删除测试文件**：修复完成后删除临时测试文件。
- 📝 **记录经验**：将调试过程中的发现、有效的日志记录点和解决方法记录下来。

### **测试文件模板**

#### **数据结构测试模板**
```python
#!/usr/bin/env python3
"""
临时测试文件 - 验证数据结构
用完即删

如何使用:
1. 导入 `utils.manga_logger`。
2. 在函数中获取或构造要测试的数据。
3. 使用日志函数记录数据信息。
4. 运行脚本查看日志输出。
"""

from utils.manga_logger import debug as log_debug, info as log_info, error as log_error, warning as log_warning

def test_data_structure():
    # 示例数据，替换为实际获取数据的逻辑
    data = {"key": "value", "number": 123}

    log_info("数据结构测试开始")
    log_info(f"数据类型: {type(data)}")
    log_debug(f"详细数据内容: {data}") # 使用 debug 记录详细内容

    if isinstance(data, dict):
        log_info(f"字典字段列表: {list(data.keys())}")
        # 根据需要添加更多日志来检查特定字段或结构
        if "key" in data:
             log_info(f"字段 'key' 的值: {data['key']}")

    log_info("数据结构测试结束")

if __name__ == "__main__":
    try:
        test_data_structure()
    except Exception as e:
        log_error("测试脚本执行时发生错误", exc_info=True)
```

#### **API测试模板**
```python
#!/usr/bin/env python3
"""
临时测试文件 - 验证API调用
用完即删

如何使用:
1. 导入 requests, json 和 `utils.manga_logger`。
2. 修改函数中的 URL 和请求参数。
3. 使用日志函数记录请求和响应信息。
4. 运行脚本查看日志输出。
"""

import requests
import json
from utils.manga_logger import debug as log_debug, info as log_info, error as log_error, warning as log_warning

def test_api():
    # 根据实际情况修改这些参数
    url = "http://localhost:8000/api/some_endpoint" # 示例URL
    # params = {"id": 123} # 示例参数
    # json_data = {"name": "test"} # 示例 JSON 数据
    
    log_info(f"API测试开始: {url}")
    
    try:
        response = requests.get(url, timeout=10) # 示例 GET 请求
        # 或者使用 post: response = requests.post(url, json=json_data, timeout=10)

        log_info(f"响应状态码: {response.status_code}")
        log_debug(f"响应头: {dict(response.headers)}")
        
        if response.status_code // 100 == 2: # 2xx 成功状态码
            try:
                data = response.json()
                log_info(f"响应数据类型: {type(data)}")
                log_debug(f"响应数据: {json.dumps(data, indent=2, ensure_ascii=False)}")
            except requests.exceptions.JSONDecodeError:
                log_warning("响应内容不是有效的JSON格式。")
                log_debug(f"原始响应文本: {response.text[:500]}...")
        else:
            log_error(f"API请求失败，状态码: {response.status_code}")
            log_debug(f"错误响应内容: {response.text[:500]}...")

    except requests.exceptions.RequestException as e:
        log_error(f"API请求失败: {e}", exc_info=True)
    except Exception as e:
        log_error(f"测试API时发生未知错误: {e}", exc_info=True)
    finally:
        log_info("API测试结束")

if __name__ == "__main__":
    test_api()
```

### **实际案例：缓存管理调试**

在缓存管理功能开发中，遇到Pydantic验证错误：
```
created_time: Input should be a valid string [type=string_type, input_value=1748705486.752638, input_type=float]
```

**错误的做法**：
- ❌ 盲猜是时间格式问题
- ❌ 直接修改API代码
- ❌ 假设所有缓存都有相同的字段名

**正确的做法**：
1. ✅ 创建`test_cache_data.py`测试文件
2. ✅ 输出所有缓存类型的实际数据结构
3. ✅ 发现不同缓存使用不同的时间字段名：
   - OCR缓存：`last_modified` (float)
   - 漫画列表缓存：`last_updated` (string)
   - 翻译缓存：`last_updated` (string)
4. ✅ 针对性修复每种缓存的字段处理
5. ✅ 删除测试文件

### **经验总结**
- 🎯 **精确定位**：测试文件和详细的日志记录帮助精确定位问题根源。
- 🚀 **提高效率**：避免反复猜测和试错，通过日志快速验证。
- 🛡️ **降低风险**：减少因盲目修改导致的新问题。
- 🪵 **善用日志级别**：使用 `log_debug()` 输出详细调试信息，`log_info()` 输出关键流程信息，`log_error()` 记录错误和异常。
- 📚 **积累经验**：每次调试都是学习机会，记录有效的日志点和分析方法。
- ❗ **异常捕获与记录**：在测试脚本和关键业务逻辑中，使用 `try...except` 捕获异常，并使用 `log_error("错误描述", exc_info=True)` 记录完整的异常信息（包括堆栈跟踪）。

### **注意事项**

- ⚠️ **及时清理**：测试文件用完立即删除
- 📁 **统一命名**：使用`test_xxx.py`格式命名
- 🔒 **避免提交**：不要将测试文件提交到版本控制
- 📝 **记录发现**：将重要发现记录到文档中

## 🌐 **Web UI 开发重要原则**

### **Vue.js 模板语法统一规则**

**⚠️ 极其重要：避免 Jinja2 与 Vue.js 语法冲突**

在 Web UI 的 HTML 模板中，**绝对禁止使用** Vue.js 的双花括号语法 `{{ }}`，因为会与 Jinja2 模板引擎冲突导致服务器报错。

**错误示例（会导致服务器崩溃）：**
```html
<!-- ❌ 绝对不要这样写 -->
<span>{{ translationProgress.completed }}</span>
<div>{{ task.fileName }}</div>
<p>{{ task.currentPage }} / {{ task.totalPages }}</p>
```

**正确示例：**
```html
<!-- ✅ 正确 - 使用 v-text 指令 -->
<span v-text="translationProgress.completed"></span>
<div v-text="task.fileName"></div>
<p><span v-text="task.currentPage"></span> / <span v-text="task.totalPages"></span></p>

<!-- ✅ 正确 - 属性绑定 -->
<div :title="task.fileName" :class="{ active: task.status === 'completed' }">

<!-- ✅ 正确 - 条件和循环 -->
<div v-if="isTranslating" v-for="task in translationTasks" :key="task.id">
```

**统一规则（必须严格遵守）：**
1. **文本显示**：使用 `v-text="expression"`
2. **HTML内容**：使用 `v-html="expression"`
3. **属性绑定**：使用 `:attribute="expression"`
4. **条件渲染**：使用 `v-if`、`v-show`、`v-else`
5. **列表渲染**：使用 `v-for`
6. **事件处理**：使用 `@event="handler"`
7. **双向绑定**：使用 `v-model="data"`

**这个原则在之前的开发中已经确立并实施，任何违反都会导致系统崩溃！**

### **常见错误和修复**

**错误类型：** `jinja2.exceptions.UndefinedError: 'variableName' is undefined`

**原因：** 在HTML模板中使用了 `{{ variableName }}` 语法

**修复方法：** 将所有 `{{ expression }}` 替换为 `v-text="expression"`

**检查清单：**
- [ ] 搜索模板中的所有 `{{` 和 `}}`
- [ ] 确认没有遗漏的双花括号语法
- [ ] 测试页面加载是否正常
- [ ] 验证动态内容显示是否正确

<!DOCTYPE html>
<html lang="zh-CN" class="theme-dark" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>漫画查看器</title>
    
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    
    <!-- 自定义样式 -->
    <link rel="stylesheet" href="/static/css/modern-theme.css">
    <link rel="stylesheet" href="/static/css/viewer.css">
</head>
<body>
    <div id="app">
        <!-- 左侧控制栏 -->
        <div class="left-sidebar">

            <!-- 漫画标题 -->
            <div class="manga-title-section">
                <div class="manga-title-vertical">{{ mangaInfo.title || '加载中...' }}</div>
            </div>

            <!-- 显示模式切换 -->
            <div class="display-mode-section">
                <el-button
                    @click="toggleDisplayMode"
                    type="primary"
                    text
                    class="mode-btn">
                    {{ actualDisplayMode === 'single' ? '单页' : '双页' }}
                </el-button>
            </div>

            <!-- 翻译开关 -->
            <div class="translation-section">
                <el-button
                    @click="toggleTranslation"
                    type="primary"
                    text
                    :class="['translation-btn', { 'translation-active': translationEnabled }]">
                    译
                </el-button>
            </div>

            <!-- 页面导航 -->
            <div class="page-navigation">
                <el-button
                    @click="previousPage"
                    :disabled="currentPage <= 0"
                    type="primary"
                    class="nav-btn">
                    ↑
                </el-button>

                <div class="page-info-section">
                    <!-- 页码显示和输入 -->
                    <div class="page-display" @click="showPageInput = true" v-if="!showPageInput">
                        <div class="current-page">{{ currentPage + 1 }}</div>
                        <div class="page-divider">/</div>
                        <div class="total-pages">{{ mangaInfo.total_pages || 0 }}</div>
                    </div>

                    <!-- 页码输入框（点击时显示） -->
                    <div class="page-input-wrapper" v-if="showPageInput">
                        <el-input
                            v-model="pageInputText"
                            size="small"
                            @blur="onPageInputBlur"
                            @keyup.enter="onPageInputEnter"
                            @keyup.escape="cancelPageInput"
                            ref="pageInputRef"
                            class="page-input">
                        </el-input>
                        <div class="page-divider">/</div>
                        <div class="total-pages">{{ mangaInfo.total_pages || 0 }}</div>
                    </div>

                    <!-- 圆形进度条 -->
                    <div class="progress-circle">
                        <svg width="60" height="60" class="progress-svg">
                            <circle cx="30" cy="30" r="25" class="progress-bg"></circle>
                            <circle cx="30" cy="30" r="25" class="progress-fill"
                                    :stroke-dasharray="progressCircumference"
                                    :stroke-dashoffset="progressOffset"></circle>
                        </svg>
                        <div class="progress-text">{{ Math.round(progressPercentage) }}%</div>
                    </div>

                    <!-- 极简滑动条 -->
                    <div class="progress-slider-section">
                        <div class="progress-slider-wrapper">
                            <div class="page-slider-container" @click="onTrackClick" ref="sliderContainer">
                                <div class="page-slider-track">
                                    <div class="page-slider-thumb" 
                                         :style="thumbStyle"
                                         @mousedown.stop="onThumbMouseDown">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <el-button
                    @click="nextPage"
                    :disabled="currentPage >= (mangaInfo.total_pages || 1) - 1"
                    type="primary"
                    class="nav-btn">
                    ↓
                </el-button>
            </div>

            <!-- 全屏按钮 -->
            <div class="fullscreen-section">
                <el-button @click="toggleFullscreen" type="primary" text class="nav-btn">
                    {{ isFullscreen ? '⊡' : '⊞' }}
                </el-button>
            </div>
        </div>

        <!-- 主要内容区域 -->
        <div class="viewer-content" ref="viewerContent">
            <!-- 加载状态 -->
            <div v-if="isLoading" class="loading-container" v-loading="true" element-loading-text="加载中...">
                <!-- v-loading 指令已应用到此 div -->
            </div>

            <!-- 图片显示区域 -->
            <div v-else-if="currentImageUrls.length > 0" class="image-container" @click="onImageClick">
                <!-- 单页模式 -->
                <img
                    v-if="actualDisplayMode === 'single'"
                    :src="currentImageUrls[0]"
                    :alt="`第 ${currentPage + 1} 页`"
                    class="manga-image single-page"
                    @load="onImageLoad"
                    @error="onImageError"
                    ref="mangaImage">

                <!-- 双页模式 -->
                <div v-else-if="actualDisplayMode === 'double'" class="double-page-container">
                    <img
                        v-for="(imageUrl, index) in currentImageUrls"
                        :key="currentPage + index"
                        :src="imageUrl"
                        :alt="`第 ${currentPage + index + 1} 页`"
                        class="manga-image double-page"
                        @load="onImageLoad"
                        @error="onImageError">
                </div>
            </div>
        </div>


    </div>

    <!-- Vue 3 和 Element Plus -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

    <!-- 实时翻译功能 -->
    <script src="/static/js/realtime_translation.js"></script>

    <script>
        const { createApp, ref, reactive, computed, watch, onMounted, onUnmounted, nextTick } = Vue;
        const { ElMessage, ElLoading } = ElementPlus;

        createApp({
            setup() {
                // 响应式数据
                const mangaInfo = reactive({
                    file_path: '',
                    title: '',
                    total_pages: 0
                });

                const currentPage = ref(0);
                const showPageInput = ref(false); // 是否显示页码输入框
                const pageInputText = ref('1'); // 页码输入框的文本值
                const currentImageUrls = ref([]);
                const nextImageUrls = ref([]); // 预加载的下一组图片
                const isLoading = ref(false);
                const isFullscreen = ref(false);
                const displayMode = ref('auto'); // 'auto', 'single', 'double'
                const translationEnabled = ref(false); // 翻译开关状态
                const screenInfo = reactive({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    ratio: window.innerWidth / window.innerHeight
                });

                // DOM引用
                const viewerContent = ref(null);
                const mangaImage = ref(null);
                const pageInputRef = ref(null);

                // 自定义滑块状态
                const sliderContainer = ref(null); // 滑块容器的引用
                const isDragging = ref(false); // 是否正在拖动
                // 获取URL参数
                const urlParams = new URLSearchParams(window.location.search);
                const mangaPath = urlParams.get('path');
                const initialPage = parseInt(urlParams.get('page') || '0');
                const themeParam = urlParams.get('theme');
                const isIframe = urlParams.get('iframe') === 'true';


                // 计算属性
                const actualDisplayMode = computed(() => {
                    if (displayMode.value === 'single') return 'single';
                    if (displayMode.value === 'double') return 'double';

                    // 自动模式：根据屏幕比例决定
                    // 宽屏显示器 (比例 > 1.5) 且屏幕宽度 > 1200px 时使用双页
                    return (screenInfo.ratio > 1.5 && screenInfo.width > 1200) ? 'double' : 'single';
                });

                const progressPercentage = computed(() => {
                    if (mangaInfo.total_pages === 0) return 0;
                    return ((currentPage.value + 1) / mangaInfo.total_pages) * 100;
                });

                const pagesToLoad = computed(() => {
                    return actualDisplayMode.value === 'double' ? 2 : 1;
                });

                // 圆形进度条计算
                const progressCircumference = computed(() => {
                    return 2 * Math.PI * 25; // 半径25的圆周长
                });

                const progressOffset = computed(() => {
                    const circumference = progressCircumference.value;
                    return circumference - (progressPercentage.value / 100) * circumference;
                });
                
                // 自定义滑块样式
                const thumbStyle = computed(() => {
                    if (!sliderContainer.value || mangaInfo.total_pages <= 1) {
                        return { top: '0px' };
                    }
                    const containerHeight = sliderContainer.value.offsetHeight;
                    const thumbHeight = 30; // 与CSS中设置的高度一致
                    const trackHeight = containerHeight - thumbHeight;
                    const percentage = currentPage.value / (mangaInfo.total_pages - 1);
                    const top = percentage * trackHeight;
                    return {
                        top: `${top}px`
                    };
                });


                // ==================== 初始化 ====================

                // 简化的主题消息监听器
                // Removed theme message listener (initThemeMessageListener) and applyCSSVars function.
                // This viewer is intentionally set to always use a dark theme (via <html class="theme-dark">)
                // and does not sync with or inherit theme from the parent page.

                // 应用CSS变量
                onMounted(async () => {
                    // 初始化实时翻译
                    if (typeof RealtimeTranslation !== 'undefined') {
                        window.realtimeTranslation = new RealtimeTranslation();
                        console.log('实时翻译模块已初始化');
                    } else {
                        console.warn('实时翻译模块未加载');
                    }

                    if (!mangaPath) {
                        ElMessage.error('缺少漫画路径参数');
                        return;
                    }

                    // 检测是否在桌面应用中，添加相应的CSS类
                    if (isDesktopApp()) {
                        document.body.classList.add('desktop-app');
                        console.log('检测到桌面应用环境，应用桌面优化样式');
                    }

                    await loadMangaInfo();
                    currentPage.value = Math.max(0, Math.min(initialPage, mangaInfo.total_pages - 1));
                    pageInputText.value = (currentPage.value + 1).toString(); // 初始化输入框
                    await loadCurrentPage();

                    // 添加事件监听
                    document.addEventListener('keydown', handleKeydown);
                    document.addEventListener('fullscreenchange', handleFullscreenChange);
                    document.addEventListener('wheel', handleWheel, { passive: false });
                    window.addEventListener('resize', handleResize);
                });

                // 检测是否在桌面应用中运行
                function isDesktopApp() {
                    return window.navigator.userAgent.includes('pywebview') ||
                           window.location.protocol === 'file:' ||
                           (!window.opener && !window.parent && window.location.hostname === '127.0.0.1');
                }

                onUnmounted(() => {
                    document.removeEventListener('keydown', handleKeydown);
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('wheel', handleWheel);
                    window.removeEventListener('resize', handleResize);
                });

                function handleResize() {
                    screenInfo.width = window.innerWidth;
                    screenInfo.height = window.innerHeight;
                    screenInfo.ratio = window.innerWidth / window.innerHeight;
console.log('窗口尺寸:', screenInfo.width, 'x', screenInfo.height);
                    if (viewerContent.value) {
                        console.log('.viewer-content 尺寸:', viewerContent.value.offsetWidth, 'x', viewerContent.value.offsetHeight);
                    }

                    // 如果是自动模式，重新加载页面以适应新的显示模式
                    if (displayMode.value === 'auto') {
                        nextTick(() => {
                            loadCurrentPage();
                        });
                    }
                }

                function handleWheel(event) {
                    event.preventDefault();

                    // 向下滚动 = 下一页，向上滚动 = 上一页
                    if (event.deltaY > 0) {
                        nextPage();
                    } else if (event.deltaY < 0) {
                        previousPage();
                    }
                }

                // ==================== 数据加载 ====================

                async function loadMangaInfo() {
                    try {
                        isLoading.value = true;
                        const response = await axios.post('/api/manga/viewer/info', {
                            manga_path: mangaPath
                        });

                        Object.assign(mangaInfo, response.data);
                        console.log('漫画信息加载成功:', mangaInfo);

                    } catch (error) {
                        console.error('加载漫画信息失败:', error);
                        ElMessage.error('加载漫画信息失败');
                    } finally {
                        isLoading.value = false;
                    }
                }

                // 图片预加载缓存
                const imageCache = new Map();
                // 请求去重机制
                const pendingPageRequests = new Map();

                async function loadPageImages(startPage, count) {
                    const imageUrls = [];

                    for (let i = 0; i < count; i++) {
                        const pageNum = startPage + i;

                        // 检查页码是否有效
                        if (pageNum >= mangaInfo.total_pages || pageNum < 0) break;

                        // 检查缓存
                        const cacheKey = `${mangaPath}_${pageNum}`;
                        if (imageCache.has(cacheKey)) {
                            imageUrls.push(imageCache.get(cacheKey));
                            console.log(`页面 ${pageNum + 1} 从缓存加载`);
                            continue;
                        }

                        // 检查是否有相同的请求正在进行
                        const requestKey = `page_${mangaPath}_${pageNum}`;
                        if (pendingPageRequests.has(requestKey)) {
                            console.log(`⏳ 页面 ${pageNum + 1} 请求正在进行中，等待结果`);
                            try {
                                const imageUrl = await pendingPageRequests.get(requestKey);
                                imageUrls.push(imageUrl);
                                continue;
                            } catch (error) {
                                console.error(`等待页面 ${pageNum + 1} 请求失败:`, error);
                                break;
                            }
                        }

                        // 创建新的请求
                        const requestPromise = loadSinglePage(mangaPath, pageNum);
                        pendingPageRequests.set(requestKey, requestPromise);

                        try {
                            const imageUrl = await requestPromise;
                            if (imageUrl) {
                                imageUrls.push(imageUrl);
                                imageCache.set(cacheKey, imageUrl);
                                console.log(`页面 ${pageNum + 1} 加载成功`);
                            } else {
                                console.warn(`页面 ${pageNum + 1} 数据无效`);
                                break;
                            }
                        } catch (error) {
                            console.error(`加载页面 ${pageNum + 1} 失败:`, error);
                            break;
                        } finally {
                            pendingPageRequests.delete(requestKey);
                        }
                    }

                    return imageUrls;
                }

                // 加载单个页面的函数
                async function loadSinglePage(mangaPath, pageNum) {
                    const response = await axios.post('/api/manga/viewer/page', {
                        manga_path: mangaPath,
                        page_num: pageNum
                    });

                    if (response.data && response.data.image) {
                        return response.data.image;
                    } else {
                        throw new Error(`页面 ${pageNum + 1} 数据无效`);
                    }
                }

                async function loadCurrentPage() {
                    try {
                        const mode = actualDisplayMode.value;
                        const pagesToLoad = mode === 'double' ? 2 : 1;

                        // 加载当前页面
                        const imageUrls = await loadPageImages(currentPage.value, pagesToLoad);

nextTick(() => {
                                if (viewerContent.value) {
                                    console.log('.viewer-content (after load) 尺寸:', viewerContent.value.offsetWidth, 'x', viewerContent.value.offsetHeight);
                                }
                                const imageContainer = document.querySelector('.image-container');
                                if (imageContainer) {
                                    console.log('.image-container 尺寸:', imageContainer.offsetWidth, 'x', imageContainer.offsetHeight);
                                }
                                const mangaImages = document.querySelectorAll('.manga-image');
                                mangaImages.forEach((img, index) => {
                                    console.log(`图片 ${index + 1} (.manga-image) 渲染尺寸:`, img.offsetWidth, 'x', img.offsetHeight);
                                });
                            });
                        if (imageUrls.length > 0) {
                            // 只有在新图片加载完成后才更新显示
                            currentImageUrls.value = imageUrls;
                            console.log(`${mode}模式加载完成，共 ${imageUrls.length} 页`);

                            // 预加载下一组页面（后台进行，不阻塞当前显示）
                            preloadNextPages();
                        } else {
                            throw new Error('无法加载任何图片');
                        }

                    } catch (error) {
                        console.error('加载页面失败:', error);
                        ElMessage.error(`加载第 ${currentPage.value + 1} 页失败`);
                        // 发生错误时不清空当前图片，保持显示
                    }
                }

                async function preloadNextPages() {
                    try {
                        const mode = actualDisplayMode.value;
                        const step = mode === 'double' ? 2 : 1;
                        const currentPageNum = currentPage.value;

                        // 预加载前后50页的范围
                        const preloadRange = 50;
                        const startPage = Math.max(0, currentPageNum - preloadRange);
                        const endPage = Math.min(mangaInfo.total_pages - 1, currentPageNum + preloadRange);

                        console.log(`预加载页面范围: ${startPage + 1} - ${endPage + 1}`);

                        // 分批预加载，避免一次性加载太多
                        const batchSize = 10;
                        for (let i = startPage; i <= endPage; i += batchSize) {
                            const batchEnd = Math.min(i + batchSize - 1, endPage);

                            // 异步预加载这一批页面
                            setTimeout(async () => {
                                try {
                                    for (let pageNum = i; pageNum <= batchEnd; pageNum++) {
                                        if (pageNum !== currentPageNum) {
                                            await loadPageImages(pageNum, 1);
                                        }
                                    }
                                    console.log(`预加载完成: 第${i + 1}-${batchEnd + 1}页`);
                                } catch (error) {
                                    console.log(`预加载批次失败 (${i + 1}-${batchEnd + 1}):`, error);
                                }
                            }, (i - startPage) * 100); // 每批间隔100ms
                        }

                        // 如果启用了翻译，也预加载翻译
                        if (translationEnabled.value && window.realtimeTranslation) {
                            const pagesToTranslate = [];
                            for (let i = startPage; i <= endPage; i++) {
                                pagesToTranslate.push(i);
                            }

                            // 分批请求翻译
                            const translationBatchSize = 20;
                            for (let i = 0; i < pagesToTranslate.length; i += translationBatchSize) {
                                const batch = pagesToTranslate.slice(i, i + translationBatchSize);
                                setTimeout(async () => {
                                    try {
                                        await window.realtimeTranslation.requestTranslation(
                                            mangaInfo.file_path,
                                            batch,
                                            1  // 低优先级，后台翻译
                                        );
                                    } catch (error) {
                                        console.log('预加载翻译失败:', error);
                                    }
                                }, i * 50); // 每批间隔50ms
                            }
                        }

                    } catch (error) {
                        // 预加载失败不影响当前显示
                        console.log('预加载失败:', error);
                    }
                }

                // ==================== 页面控制 ====================

                function previousPage() {
                    const step = actualDisplayMode.value === 'double' ? 2 : 1;
                    if (currentPage.value > 0) {
                        const newPage = Math.max(0, currentPage.value - step);
                        onPageChange(newPage);
                    }
                }

                function nextPage() {
                    const step = actualDisplayMode.value === 'double' ? 2 : 1;
                    if (currentPage.value < mangaInfo.total_pages - 1) {
                        const newPage = Math.min(mangaInfo.total_pages - 1, currentPage.value + step);
                        onPageChange(newPage);
                    }
                }

                async function onPageChange(newPage) {
                    currentPage.value = newPage;
                    pageInputText.value = (newPage + 1).toString(); // 同步更新输入框文本
                    loadCurrentPage();

                    // 如果启用了翻译，请求翻译当前页面和周围页面
                    if (translationEnabled.value && window.realtimeTranslation) {
                        try {
                            const pagesToTranslate = [];
                            for (let i = Math.max(0, newPage - 5);
                                 i <= Math.min(mangaInfo.total_pages - 1, newPage + 5);
                                 i++) {
                                pagesToTranslate.push(i);
                            }

                            await window.realtimeTranslation.requestTranslation(
                                mangaInfo.file_path,
                                pagesToTranslate,
                                5  // 高优先级
                            );
                        } catch (error) {
                            console.log('请求翻译失败:', error);
                        }
                    }
                }

                // 页码输入相关方法
                function onPageInputEnter() {
                    applyPageInput();
                }

                function onPageInputBlur() {
                    applyPageInput();
                }

                function cancelPageInput() {
                    showPageInput.value = false;
                    pageInputText.value = (currentPage.value + 1).toString(); // 恢复原值
                }

                function applyPageInput() {
                    const newPage = parseInt(pageInputText.value);
                    if (newPage && newPage >= 1 && newPage <= mangaInfo.total_pages) {
                        currentPage.value = newPage - 1; // 转换为0-based
                        loadCurrentPage();
                    } else {
                        // 输入无效，恢复原值
                        pageInputText.value = (currentPage.value + 1).toString();
                    }
                    showPageInput.value = false;
                }

                // ==================== 自定义滑块方法 ====================

                function onThumbMouseDown(event) {
                    isDragging.value = true;
                    const thumb = event.target;
                    const container = sliderContainer.value;
                    const initialY = event.clientY;
                    const initialTop = thumb.offsetTop;

                    const onMouseMove = (moveEvent) => {
                        if (!isDragging.value) return;

                        const deltaY = moveEvent.clientY - initialY;
                        let newTop = initialTop + deltaY;

                        const containerHeight = container.offsetHeight;
                        const thumbHeight = thumb.offsetHeight;
                        
                        // 限制在轨道内
                        newTop = Math.max(0, Math.min(newTop, containerHeight - thumbHeight));
                        
                        const percentage = newTop / (containerHeight - thumbHeight);
                        const newPage = Math.round(percentage * (mangaInfo.total_pages - 1));
                        
                        // 仅更新预览页码，不立即跳转
                        pageInputText.value = (newPage + 1).toString();
                        
                        // 直接更新样式以获得即时反馈
                        thumb.style.top = `${newTop}px`;
                    };

                    const onMouseUp = () => {
                        isDragging.value = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);

                        // 拖动结束后，根据最终位置计算并跳转页面
                        const finalPercentage = thumb.offsetTop / (container.offsetHeight - thumb.offsetHeight);
                        const finalPage = Math.round(finalPercentage * (mangaInfo.total_pages - 1));
                        if (finalPage !== currentPage.value) {
                            onPageChange(finalPage);
                        }
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                }

                function onTrackClick(event) {
                    if (isDragging.value) return;

                    const container = sliderContainer.value;
                    const rect = container.getBoundingClientRect();
                    const clickY = event.clientY - rect.top;
                    
                    const containerHeight = container.offsetHeight;
                    const thumbHeight = 30; // 硬编码与CSS一致
                    
                    let percentage = clickY / containerHeight;
                    // 调整，使点击中心大致对齐滑块中心
                    percentage = (clickY - (thumbHeight / 2)) / (containerHeight - thumbHeight);
                    percentage = Math.max(0, Math.min(1, percentage));

                    const newPage = Math.round(percentage * (mangaInfo.total_pages - 1));
                    
                    if (newPage !== currentPage.value) {
                        onPageChange(newPage);
                    }
                }
                
                // 监听页码输入框显示状态，自动聚焦
                watch(showPageInput, (newValue) => {
                    if (newValue) {
                        nextTick(() => {
                            if (pageInputRef.value) {
                                pageInputRef.value.focus();
                                pageInputRef.value.select(); // 选中所有文本
                            }
                        });
                    }
                });

                function toggleDisplayMode() {
                    if (displayMode.value === 'auto') {
                        displayMode.value = 'single';
                    } else if (displayMode.value === 'single') {
                        displayMode.value = 'double';
                    } else {
                        displayMode.value = 'auto';
                    }
                    loadCurrentPage();
const img = event.target;
                    console.log(`图片加载完成 - src: ${img.src}`);
                    console.log(`图片自然尺寸: ${img.naturalWidth} x ${img.naturalHeight}`);
                    console.log(`图片渲染尺寸: ${img.offsetWidth} x ${img.offsetHeight}`);
const computedStyle = window.getComputedStyle(img);
                    console.log('图片计算样式:', {
                        width: computedStyle.width,
                        height: computedStyle.height,
                        maxWidth: computedStyle.maxWidth,
                        maxHeight: computedStyle.maxHeight,
                        objectFit: computedStyle.objectFit,
                    });

                    const doublePage = img.closest('.double-page');
                    if (doublePage) {
                        const dpStyle = window.getComputedStyle(doublePage);
                        console.log('.double-page 尺寸:', doublePage.offsetWidth, 'x', doublePage.offsetHeight);
                        console.log('.double-page 计算样式:', {
                            width: dpStyle.width,
                            height: dpStyle.height,
                            maxWidth: dpStyle.maxWidth,
                            maxHeight: dpStyle.maxHeight,
                        });
                    }

                    const doublePageContainer = img.closest('.double-page-container');
                    if (doublePageContainer) {
                        const dpcStyle = window.getComputedStyle(doublePageContainer);
                        console.log('.double-page-container 尺寸:', doublePageContainer.offsetWidth, 'x', doublePageContainer.offsetHeight);
                        console.log('.double-page-container 计算样式:', {
                            width: dpcStyle.width,
                            height: dpcStyle.height,
                            maxWidth: dpcStyle.maxWidth,
                            maxHeight: dpcStyle.maxHeight,
                        });
                    }
                }

                async function toggleTranslation() {
                    translationEnabled.value = !translationEnabled.value;

                    if (translationEnabled.value) {
                        try {
                            // 启动实时翻译服务
                            console.log('启动实时翻译服务...');
                            const success = await window.realtimeTranslation.startService('智谱');

                            if (success) {
                                ElMessage.success('实时翻译已启用');

                                // 设置当前漫画
                                await window.realtimeTranslation.setCurrentManga(
                                    currentManga.value.file_path,
                                    currentPageIndex.value
                                );

                                // 请求翻译当前页面和周围页面
                                const pagesToTranslate = [];
                                for (let i = Math.max(0, currentPageIndex.value - 2);
                                     i <= Math.min(currentManga.value.total_pages - 1, currentPageIndex.value + 2);
                                     i++) {
                                    pagesToTranslate.push(i);
                                }

                                await window.realtimeTranslation.requestTranslation(
                                    currentManga.value.file_path,
                                    pagesToTranslate,
                                    5  // 高优先级
                                );

                                console.log('实时翻译服务启动成功');
                            } else {
                                throw new Error('启动翻译服务失败');
                            }
                        } catch (error) {
                            console.error('启动翻译服务失败:', error);
                            ElMessage.error('启动翻译服务失败: ' + error.message);
                            translationEnabled.value = false;
                        }
                    } else {
                        try {
                            // 停止翻译服务
                            await window.realtimeTranslation.stopService();
                            ElMessage.info('实时翻译已关闭');
                            console.log('翻译功能已关闭');
                        } catch (error) {
                            console.error('停止翻译服务失败:', error);
                            ElMessage.warning('停止翻译服务失败: ' + error.message);
                        }
                    }
                }

                // ==================== 事件处理 ====================

                function handleKeydown(event) {
                    switch (event.key) {
                        case 'ArrowLeft':
                            event.preventDefault();
                            previousPage();
                            break;
                        case 'ArrowRight':
                            event.preventDefault();
                            nextPage();
                            break;
                        case 'Escape':
                            if (isFullscreen.value) {
                                exitFullscreen();
                            }
                            break;
                        case 'F11':
                            event.preventDefault();
                            toggleFullscreen();
                            break;
                    }
                }

                function onImageClick(event) {
                    // 点击图片左半部分上一页，右半部分下一页
                    const rect = event.currentTarget.getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const centerX = rect.width / 2;

                    if (clickX < centerX) {
                        previousPage();
                    } else {
                        nextPage();
                    }
                }

                function onImageLoad() {
                    console.log('图片加载完成');
                }

                function onImageError() {
                    console.error('图片加载失败');
                    ElMessage.error('图片加载失败');
                }

                // ==================== 全屏控制 ====================

                function toggleFullscreen() {
                    if (isFullscreen.value) {
                        exitFullscreen();
                    } else {
                        enterFullscreen();
                    }
                }

                function enterFullscreen() {
                    const element = viewerContent.value;
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                }

                function exitFullscreen() {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }

                function handleFullscreenChange() {
                    isFullscreen.value = !!document.fullscreenElement;
                }

                // ==================== 导航 ====================
                // iframe方案不需要返回按钮，由父页面控制关闭

                return {
                    // 数据
                    mangaInfo,
                    currentPage,
                    showPageInput,
                    pageInputText,
                    currentImageUrls,
                    isLoading,
                    isFullscreen,
                    displayMode,
                    actualDisplayMode,
                    translationEnabled,
                    progressPercentage,
                    progressCircumference,
                    progressOffset,
                    screenInfo,
                    thumbStyle,
                    isDragging,

                    // DOM引用
                    viewerContent,
                    mangaImage,
                    pageInputRef,
                    sliderContainer,

                    // 方法
                    loadCurrentPage,
                    previousPage,
                    nextPage,
                    onPageChange,
                    onPageInputEnter,
                    onPageInputBlur,
                    cancelPageInput,
                    applyPageInput,
                    toggleDisplayMode,
                    toggleTranslation,
                    onImageClick,
                    onImageLoad,
                    onImageError,
                    toggleFullscreen,
                    onThumbMouseDown,
                    onTrackClick
                };
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>

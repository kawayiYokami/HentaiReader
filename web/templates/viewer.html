<!DOCTYPE html>
<html lang="zh-CN" class="theme-dark" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¼«ç”»æŸ¥çœ‹å™¨</title>
    
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    
    <!-- è‡ªå®šä¹‰æ ·å¼ -->
    <link rel="stylesheet" href="/static/css/modern-theme.css">
    <link rel="stylesheet" href="/static/css/viewer.css">

</head>
<body>
    <div id="app">
        <!-- å·¦ä¾§æ§åˆ¶æ  -->
        <div class="left-sidebar">

            <!-- æ¼«ç”»æ ‡é¢˜ -->
            <div class="manga-title-section">
                <div class="manga-title-vertical">{{ mangaInfo.title || 'åŠ è½½ä¸­...' }}</div>
            </div>

            <!-- æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢ -->
            <div class="display-mode-section">
                <el-button
                    @click="toggleDisplayMode"
                    type="primary"
                    text
                    class="mode-btn">
                    {{ actualDisplayMode === 'single' ? 'å•é¡µ' : 'åŒé¡µ' }}
                </el-button>
            </div>

            <!-- ç¿»è¯‘å¼€å…³ -->
            <div class="translation-section">
                <el-button
                    @click="toggleTranslation"
                    type="primary"
                    text
                    :class="['translation-btn', { 'translation-active': translationEnabled }]">
                    è¯‘
                </el-button>
            </div>

            <!-- é¡µé¢å¯¼èˆª -->
            <div class="page-navigation">
                <el-button
                    @click="previousPage"
                    :disabled="currentPage <= 0"
                    type="primary"
                    class="nav-btn">
                    â†‘
                </el-button>

                <div class="page-info-section">
                    <!-- é¡µç æ˜¾ç¤ºå’Œè¾“å…¥ -->
                    <div class="page-display" @click="showPageInput = true" v-if="!showPageInput">
                        <div class="current-page">{{ currentPage + 1 }}</div>
                        <div class="page-divider">/</div>
                        <div class="total-pages">{{ mangaInfo.total_pages || 0 }}</div>
                    </div>

                    <!-- é¡µç è¾“å…¥æ¡†ï¼ˆç‚¹å‡»æ—¶æ˜¾ç¤ºï¼‰ -->
                    <div class="page-input-wrapper" v-if="showPageInput">
                        <el-input
                            v-model="pageInputText"
                            size="small"
                            @blur="onPageInputBlur"
                            @keyup.enter="onPageInputEnter"
                            @keyup.escape="cancelPageInput"
                            ref="pageInputRef"
                            class="page-input">
                        </el-input>
                        <div class="page-divider">/</div>
                        <div class="total-pages">{{ mangaInfo.total_pages || 0 }}</div>
                    </div>

                    <!-- åœ†å½¢è¿›åº¦æ¡ -->
                    <div class="progress-circle">
                        <svg width="60" height="60" class="progress-svg">
                            <circle cx="30" cy="30" r="25" class="progress-bg"></circle>
                            <circle cx="30" cy="30" r="25" class="progress-fill"
                                    :stroke-dasharray="progressCircumference"
                                    :stroke-dashoffset="progressOffset"></circle>
                        </svg>
                        <div class="progress-text">{{ Math.round(progressPercentage) }}%</div>
                    </div>

                    <!-- æç®€æ»‘åŠ¨æ¡ -->
                    <div class="progress-slider-section">
                        <div class="progress-slider-wrapper">
                            <div class="page-slider-container" @click="onTrackClick" ref="sliderContainer">
                                <div class="page-slider-track">
                                    <div class="page-slider-thumb" 
                                         :style="thumbStyle"
                                         @mousedown.stop="onThumbMouseDown">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <el-button
                    @click="nextPage"
                    :disabled="currentPage >= (mangaInfo.total_pages || 1) - 1"
                    type="primary"
                    class="nav-btn">
                    â†“
                </el-button>
            </div>

            <!-- å…¨å±æŒ‰é’® -->
            <div class="fullscreen-section">
                <el-button @click="toggleFullscreen" type="primary" text class="nav-btn">
                    {{ isFullscreen ? 'âŠ¡' : 'âŠ' }}
                </el-button>
            </div>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="viewer-content" ref="viewerContent">
            <!-- åŠ è½½çŠ¶æ€ -->
            <div v-if="isLoading" class="loading-container" v-loading="true" element-loading-text="åŠ è½½ä¸­...">
                <!-- v-loading æŒ‡ä»¤å·²åº”ç”¨åˆ°æ­¤ div -->
            </div>

            <!-- å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸ -->
            <div v-else-if="currentImageUrls.length > 0" class="image-container" @click="onImageClick">
                <!-- å•é¡µæ¨¡å¼ -->
                <img
                    v-if="actualDisplayMode === 'single'"
                    :src="currentImageUrls[0]"
                    :alt="`ç¬¬ ${currentPage + 1} é¡µ`"
                    class="manga-image single-page"
                    loading="eager"
                    decoding="sync"
                    @load="onImageLoad"
                    @error="onImageError"
                    ref="mangaImage">

                <!-- åŒé¡µæ¨¡å¼ -->
                <div v-else-if="actualDisplayMode === 'double'" class="double-page-container">
                    <img
                        v-for="(imageUrl, index) in currentImageUrls"
                        :key="currentPage + index"
                        :src="imageUrl"
                        :alt="`ç¬¬ ${currentPage + index + 1} é¡µ`"
                        class="manga-image double-page"
                        loading="eager"
                        decoding="sync"
                        @load="onImageLoad"
                        @error="onImageError">
                </div>
            </div>
        </div>


    </div>

    <!-- Vue 3 å’Œ Element Plus -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>


    <!-- å®æ—¶ç¿»è¯‘åŠŸèƒ½ -->
    <script src="/static/js/realtime_translation.js"></script>

    <script>
        const { createApp, ref, reactive, computed, watch, onMounted, onUnmounted, nextTick } = Vue;
        const { ElMessage, ElLoading } = ElementPlus;

        createApp({
            setup() {
                // å“åº”å¼æ•°æ®
                const mangaInfo = reactive({
                    file_path: '',
                    title: '',
                    total_pages: 0
                });

                const currentPage = ref(0);
                const showPageInput = ref(false); // æ˜¯å¦æ˜¾ç¤ºé¡µç è¾“å…¥æ¡†
                const pageInputText = ref('1'); // é¡µç è¾“å…¥æ¡†çš„æ–‡æœ¬å€¼
                const currentImageUrls = ref([]);
                const nextImageUrls = ref([]); // é¢„åŠ è½½çš„ä¸‹ä¸€ç»„å›¾ç‰‡
                const isLoading = ref(false);
                const isFullscreen = ref(false);
                const displayMode = ref('auto'); // 'auto', 'single', 'double'
                const translationEnabled = ref(false); // ç¿»è¯‘å¼€å…³çŠ¶æ€


                const screenInfo = reactive({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    ratio: window.innerWidth / window.innerHeight
                });

                // DOMå¼•ç”¨
                const viewerContent = ref(null);
                const mangaImage = ref(null);
                const pageInputRef = ref(null);

                // è‡ªå®šä¹‰æ»‘å—çŠ¶æ€
                const sliderContainer = ref(null); // æ»‘å—å®¹å™¨çš„å¼•ç”¨
                const isDragging = ref(false); // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨
                // è·å–URLå‚æ•°
                const urlParams = new URLSearchParams(window.location.search);
                const mangaPath = urlParams.get('path');
                const initialPage = parseInt(urlParams.get('page') || '0');
                const themeParam = urlParams.get('theme');
                const isIframe = urlParams.get('iframe') === 'true';


                // è®¡ç®—å±æ€§
                const actualDisplayMode = computed(() => {
                    if (displayMode.value === 'single') return 'single';
                    if (displayMode.value === 'double') return 'double';

                    // è‡ªåŠ¨æ¨¡å¼ï¼šæ ¹æ®å±å¹•æ¯”ä¾‹å†³å®š
                    // å®½å±æ˜¾ç¤ºå™¨ (æ¯”ä¾‹ > 1.5) ä¸”å±å¹•å®½åº¦ > 1200px æ—¶ä½¿ç”¨åŒé¡µ
                    return (screenInfo.ratio > 1.5 && screenInfo.width > 1200) ? 'double' : 'single';
                });

                const progressPercentage = computed(() => {
                    if (mangaInfo.total_pages === 0) return 0;
                    return ((currentPage.value + 1) / mangaInfo.total_pages) * 100;
                });

                const pagesToLoad = computed(() => {
                    return actualDisplayMode.value === 'double' ? 2 : 1;
                });

                // åœ†å½¢è¿›åº¦æ¡è®¡ç®—
                const progressCircumference = computed(() => {
                    return 2 * Math.PI * 25; // åŠå¾„25çš„åœ†å‘¨é•¿
                });

                const progressOffset = computed(() => {
                    const circumference = progressCircumference.value;
                    return circumference - (progressPercentage.value / 100) * circumference;
                });


                
                // è‡ªå®šä¹‰æ»‘å—æ ·å¼
                const thumbStyle = computed(() => {
                    if (!sliderContainer.value || mangaInfo.total_pages <= 1) {
                        return { top: '0px' };
                    }
                    const containerHeight = sliderContainer.value.offsetHeight;
                    const thumbHeight = 30; // ä¸CSSä¸­è®¾ç½®çš„é«˜åº¦ä¸€è‡´
                    const trackHeight = containerHeight - thumbHeight;
                    const percentage = currentPage.value / (mangaInfo.total_pages - 1);
                    const top = percentage * trackHeight;
                    return {
                        top: `${top}px`
                    };
                });


                // ==================== åˆå§‹åŒ– ====================

                // ç®€åŒ–çš„ä¸»é¢˜æ¶ˆæ¯ç›‘å¬å™¨
                // Removed theme message listener (initThemeMessageListener) and applyCSSVars function.
                // This viewer is intentionally set to always use a dark theme (via <html class="theme-dark">)
                // and does not sync with or inherit theme from the parent page.



                // åº”ç”¨CSSå˜é‡
                onMounted(async () => {

                    // åˆå§‹åŒ–å®æ—¶ç¿»è¯‘
                    try {
                        if (typeof RealtimeTranslation !== 'undefined') {
                            window.realtimeTranslation = new RealtimeTranslation();
                            console.log('å®æ—¶ç¿»è¯‘æ¨¡å—å·²åˆå§‹åŒ–');
                        } else if (typeof RealtimeTranslationManager !== 'undefined') {
                            window.realtimeTranslation = new RealtimeTranslationManager();
                            console.log('å®æ—¶ç¿»è¯‘ç®¡ç†å™¨å·²åˆå§‹åŒ–');
                        } else {
                            console.warn('å®æ—¶ç¿»è¯‘æ¨¡å—æœªåŠ è½½');
                        }

                        // è®¾ç½®ç¿»è¯‘å®Œæˆå›è°ƒï¼ˆå¦‚æœå®æ—¶ç¿»è¯‘æ¨¡å—å¯ç”¨ï¼‰
                        if (window.realtimeTranslation) {
                            window.realtimeTranslation.onTranslationCompleted = (mangaPath, pageIndex, imageData) => {
                                console.log(`ç¿»è¯‘å®Œæˆå›è°ƒ: é¡µé¢ ${pageIndex + 1}`);

                                // å¦‚æœæ˜¯å½“å‰æ˜¾ç¤ºçš„é¡µé¢ï¼Œåˆ·æ–°æ˜¾ç¤º
                                if (mangaPath === mangaInfo.file_path) {
                                    const mode = actualDisplayMode.value;
                                    const currentPageNum = currentPage.value;

                                    // æ¸…é™¤ç›¸å…³é¡µé¢çš„ç¼“å­˜
                                    clearPageCache(pageIndex);

                                    // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰æ˜¾ç¤ºçš„é¡µé¢
                                    if (mode === 'single' && pageIndex === currentPageNum) {
                                        console.log(`åˆ·æ–°å½“å‰é¡µé¢æ˜¾ç¤º: ${pageIndex + 1}`);
                                        loadCurrentPage();
                                    } else if (mode === 'double' && (pageIndex === currentPageNum || pageIndex === currentPageNum + 1)) {
                                        console.log(`åˆ·æ–°åŒé¡µæ˜¾ç¤º: ${pageIndex + 1}`);
                                        loadCurrentPage();
                                    }
                                }
                            };
                        }
                    } catch (error) {
                        console.error('åˆå§‹åŒ–å®æ—¶ç¿»è¯‘æ¨¡å—å¤±è´¥:', error);
                    }

                    if (!mangaPath) {
                        ElMessage.error('ç¼ºå°‘æ¼«ç”»è·¯å¾„å‚æ•°');
                        return;
                    }

                    // æ£€æµ‹æ˜¯å¦åœ¨æ¡Œé¢åº”ç”¨ä¸­ï¼Œæ·»åŠ ç›¸åº”çš„CSSç±»
                    if (isDesktopApp()) {
                        document.body.classList.add('desktop-app');
                        console.log('æ£€æµ‹åˆ°æ¡Œé¢åº”ç”¨ç¯å¢ƒï¼Œåº”ç”¨æ¡Œé¢ä¼˜åŒ–æ ·å¼');
                    }

                    await loadMangaInfo();
                    currentPage.value = Math.max(0, Math.min(initialPage, mangaInfo.total_pages - 1));
                    pageInputText.value = (currentPage.value + 1).toString(); // åˆå§‹åŒ–è¾“å…¥æ¡†
                    await loadCurrentPage();

                    // æ·»åŠ äº‹ä»¶ç›‘å¬
                    document.addEventListener('keydown', handleKeydown);
                    document.addEventListener('fullscreenchange', handleFullscreenChange);
                    document.addEventListener('wheel', handleWheel, { passive: false });
                    window.addEventListener('resize', handleResize);
                });

                // æ£€æµ‹æ˜¯å¦åœ¨æ¡Œé¢åº”ç”¨ä¸­è¿è¡Œ
                function isDesktopApp() {
                    return window.navigator.userAgent.includes('pywebview') ||
                           window.location.protocol === 'file:' ||
                           (!window.opener && !window.parent && window.location.hostname === '127.0.0.1');
                }

                onUnmounted(() => {
                    document.removeEventListener('keydown', handleKeydown);
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('wheel', handleWheel);
                    window.removeEventListener('resize', handleResize);
                });

                function handleResize() {
                    screenInfo.width = window.innerWidth;
                    screenInfo.height = window.innerHeight;
                    screenInfo.ratio = window.innerWidth / window.innerHeight;
console.log('çª—å£å°ºå¯¸:', screenInfo.width, 'x', screenInfo.height);
                    if (viewerContent.value) {
                        console.log('.viewer-content å°ºå¯¸:', viewerContent.value.offsetWidth, 'x', viewerContent.value.offsetHeight);
                    }

                    // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ï¼Œé‡æ–°åŠ è½½é¡µé¢ä»¥é€‚åº”æ–°çš„æ˜¾ç¤ºæ¨¡å¼
                    if (displayMode.value === 'auto') {
                        nextTick(() => {
                            loadCurrentPage();
                        });
                    }
                }

                function handleWheel(event) {
                    event.preventDefault();

                    // å‘ä¸‹æ»šåŠ¨ = ä¸‹ä¸€é¡µï¼Œå‘ä¸Šæ»šåŠ¨ = ä¸Šä¸€é¡µ
                    if (event.deltaY > 0) {
                        nextPage();
                    } else if (event.deltaY < 0) {
                        previousPage();
                    }
                }

                // ==================== æ•°æ®åŠ è½½ ====================

                async function loadMangaInfo() {
                    try {
                        isLoading.value = true;
                        const response = await axios.post('/api/manga/viewer/info', {
                            manga_path: mangaPath
                        });

                        Object.assign(mangaInfo, response.data);
                        console.log('æ¼«ç”»ä¿¡æ¯åŠ è½½æˆåŠŸ:', mangaInfo);

                    } catch (error) {
                        console.error('åŠ è½½æ¼«ç”»ä¿¡æ¯å¤±è´¥:', error);
                        ElMessage.error('åŠ è½½æ¼«ç”»ä¿¡æ¯å¤±è´¥');
                    } finally {
                        isLoading.value = false;
                    }
                }

                // ==================== å‰ç«¯ç¼“å­˜ç³»ç»Ÿ ====================

                // å‰ç«¯ç¼“å­˜é…ç½®
                const frontendCacheConfig = {
                    maxSize: 50,           // æœ€å¤§ç¼“å­˜é¡µé¢æ•°
                    cleanupThreshold: 60,  // æ¸…ç†é˜ˆå€¼
                    accessTimeout: 30 * 60 * 1000, // 30åˆ†é’Ÿè®¿é—®è¶…æ—¶
                };

                // å‰ç«¯é¡µé¢ç¼“å­˜ï¼ˆä»…ç¼“å­˜ç”¨æˆ·å·²è®¿é—®çš„é¡µé¢ï¼‰
                const imageCache = new Map();

                // ç¼“å­˜å…ƒæ•°æ®ï¼ˆè®¿é—®æ—¶é—´ã€ç±»å‹ç­‰ï¼‰
                const cacheMetadata = new Map();

                // è¯·æ±‚å»é‡æœºåˆ¶
                const pendingPageRequests = new Map();

                // ç¼“å­˜ç®¡ç†å‡½æ•°
                function updateCacheAccess(cacheKey) {
                    const metadata = cacheMetadata.get(cacheKey) || {};
                    metadata.lastAccess = Date.now();
                    metadata.accessCount = (metadata.accessCount || 0) + 1;
                    cacheMetadata.set(cacheKey, metadata);
                }

                function cleanupExpiredCache() {
                    const now = Date.now();
                    let cleanedCount = 0;

                    for (const [key, metadata] of cacheMetadata.entries()) {
                        if (now - metadata.lastAccess > frontendCacheConfig.accessTimeout) {
                            imageCache.delete(key);
                            cacheMetadata.delete(key);
                            cleanedCount++;
                        }
                    }

                    // å¦‚æœç¼“å­˜è¿‡å¤§ï¼Œæ¸…ç†æœ€å°‘ä½¿ç”¨çš„
                    if (imageCache.size > frontendCacheConfig.cleanupThreshold) {
                        const entries = [...cacheMetadata.entries()]
                            .sort(([,a], [,b]) => a.lastAccess - b.lastAccess);

                        const toRemove = entries.slice(0, imageCache.size - frontendCacheConfig.maxSize);
                        for (const [key] of toRemove) {
                            imageCache.delete(key);
                            cacheMetadata.delete(key);
                            cleanedCount++;
                        }
                    }

                    if (cleanedCount > 0) {
                        console.log(`ğŸ§¹ å‰ç«¯ç¼“å­˜æ¸…ç†: ç§»é™¤${cleanedCount}é¡¹ï¼Œå½“å‰å¤§å°${imageCache.size}`);
                    }
                }

                // å®šæœŸæ¸…ç†ç¼“å­˜
                setInterval(cleanupExpiredCache, 5 * 60 * 1000); // æ¯5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡

                // æ¸…é™¤æŒ‡å®šé¡µé¢çš„ç¼“å­˜ï¼ˆæ”¯æŒç±»å‹æŒ‡å®šï¼‰
                function clearPageCache(pageNum, type = 'all') {
                    const timestamp = new Date().toLocaleTimeString();
                    let clearedCount = 0;

                    if (type === 'all' || type === 'original') {
                        const origKey = generateCacheKey(mangaPath, pageNum, 'original');
                        if (imageCache.has(origKey)) {
                            imageCache.delete(origKey);
                            clearedCount++;
                            console.log(`ğŸ—‘ï¸ [${timestamp}] æ¸…é™¤é¡µé¢ ${pageNum + 1} åŸå§‹ç¼“å­˜ (é”®: ${origKey})`);
                        }
                    }

                    if (type === 'all' || type === 'translated') {
                        const transKey = generateCacheKey(mangaPath, pageNum, 'translated');
                        if (imageCache.has(transKey)) {
                            imageCache.delete(transKey);
                            clearedCount++;
                            console.log(`ğŸ—‘ï¸ [${timestamp}] æ¸…é™¤é¡µé¢ ${pageNum + 1} ç¿»è¯‘ç¼“å­˜ (é”®: ${transKey})`);
                        }
                    }

                    if (clearedCount === 0) {
                        console.log(`â„¹ï¸ [${timestamp}] é¡µé¢ ${pageNum + 1} æ— ${type}ç¼“å­˜éœ€è¦æ¸…é™¤`);
                    }

                    return clearedCount;
                }

                // æ¸…é™¤æ‰€æœ‰é¡µé¢ç¼“å­˜ï¼ˆæ”¯æŒç±»å‹è¿‡æ»¤ï¼‰
                function clearAllPageCache(type = 'all') {
                    const timestamp = new Date().toLocaleTimeString();
                    let clearedCount = 0;
                    const keysToDelete = [];

                    // æ”¶é›†éœ€è¦åˆ é™¤çš„é”®
                    for (const [key, value] of imageCache.entries()) {
                        if (type === 'all') {
                            keysToDelete.push(key);
                        } else if (type === 'original' && key.startsWith('ORIG_')) {
                            keysToDelete.push(key);
                        } else if (type === 'translated' && key.startsWith('TRANS_')) {
                            keysToDelete.push(key);
                        }
                    }

                    // åˆ é™¤æ”¶é›†çš„é”®
                    keysToDelete.forEach(key => {
                        imageCache.delete(key);
                        clearedCount++;
                    });

                    console.log(`ğŸ—‘ï¸ [${timestamp}] æ¸…é™¤${type}é¡µé¢ç¼“å­˜ï¼Œå…± ${clearedCount} é¡¹`);
                    return clearedCount;
                }

                // æ¸…é™¤ç¿»è¯‘ç›¸å…³ç¼“å­˜
                function clearTranslationCache() {
                    const timestamp = new Date().toLocaleTimeString();
                    let totalCleared = 0;

                    // æ¸…é™¤å‰ç«¯é¡µé¢ç¿»è¯‘ç¼“å­˜
                    const pageCleared = clearAllPageCache('translated');
                    totalCleared += pageCleared;

                    // æ¸…é™¤å®æ—¶ç¿»è¯‘æ¨¡å—ç¼“å­˜
                    if (window.realtimeTranslation) {
                        try {
                            const moduleCleared = window.realtimeTranslation.clearCache('translated');
                            totalCleared += moduleCleared;
                            console.log(`ğŸ—‘ï¸ [${timestamp}] æ¸…é™¤å®æ—¶ç¿»è¯‘æ¨¡å—ç¼“å­˜ï¼Œå…± ${moduleCleared} é¡¹`);
                        } catch (error) {
                            console.warn(`âš ï¸ [${timestamp}] æ¸…é™¤å®æ—¶ç¿»è¯‘æ¨¡å—ç¼“å­˜å¤±è´¥:`, error);
                        }
                    }

                    console.log(`âœ… [${timestamp}] ç¿»è¯‘ç¼“å­˜æ¸…é™¤å®Œæˆï¼Œæ€»è®¡ ${totalCleared} é¡¹`);
                    return totalCleared;
                }

                // åˆ·æ–°æ‰€æœ‰å·²ç¿»è¯‘çš„é¡µé¢ç¼“å­˜
                async function refreshTranslatedPages() {
                    if (!translationEnabled.value || !window.realtimeTranslation) {
                        return;
                    }

                    try {
                        // è·å–æ‰€æœ‰é¡µé¢çš„ç¿»è¯‘çŠ¶æ€
                        const allPages = Array.from({length: mangaInfo.total_pages}, (_, i) => i);
                        const translatedStatus = await window.realtimeTranslation.checkPagesTranslated(
                            mangaInfo.file_path,
                            allPages
                        );

                        // æ¸…é™¤å·²ç¿»è¯‘é¡µé¢çš„ç¼“å­˜ï¼Œå¼ºåˆ¶é‡æ–°åŠ è½½
                        for (const [pageIndexStr, isTranslated] of Object.entries(translatedStatus)) {
                            if (isTranslated) {
                                const pageIndex = parseInt(pageIndexStr);
                                clearPageCache(pageIndex);
                                console.log(`å‘ç°å·²ç¿»è¯‘é¡µé¢ï¼Œæ¸…é™¤ç¼“å­˜: é¡µé¢ ${pageIndex + 1}`);
                            }
                        }

                        // å¦‚æœå½“å‰é¡µé¢å·²ç¿»è¯‘ï¼Œé‡æ–°åŠ è½½
                        const currentPageTranslated = translatedStatus[currentPage.value.toString()];
                        if (currentPageTranslated) {
                            console.log(`å½“å‰é¡µé¢å·²ç¿»è¯‘ï¼Œé‡æ–°åŠ è½½: é¡µé¢ ${currentPage.value + 1}`);
                            await loadCurrentPage();
                        }

                    } catch (error) {
                        console.log('åˆ·æ–°ç¿»è¯‘é¡µé¢å¤±è´¥:', error);
                    }
                }

                async function loadPageImages(startPage, count, forceOriginal = false) {
                    const imageUrls = [];
                    const timestamp = new Date().toLocaleTimeString();
                    console.log(`ğŸ”„ [${timestamp}] å¼€å§‹åŠ è½½é¡µé¢: èµ·å§‹é¡µ${startPage + 1}, æ•°é‡${count}, å¼ºåˆ¶åŸå§‹=${forceOriginal}`);

                    for (let i = 0; i < count; i++) {
                        const pageNum = startPage + i;

                        // æ£€æŸ¥é¡µç æ˜¯å¦æœ‰æ•ˆ
                        if (pageNum >= mangaInfo.total_pages || pageNum < 0) {
                            console.log(`âš ï¸ [${timestamp}] é¡µé¢${pageNum + 1}è¶…å‡ºèŒƒå›´ï¼Œåœæ­¢åŠ è½½`);
                            break;
                        }

                        // ç”Ÿæˆæ­£ç¡®çš„ç¼“å­˜é”®å€¼
                        const expectedType = (translationEnabled.value && !forceOriginal) ? 'translated' : 'original';
                        const cacheKey = generateCacheKey(mangaPath, pageNum, expectedType);

                        // æ£€æŸ¥ç¼“å­˜ï¼ˆæ ¹æ®å½“å‰ç¿»è¯‘çŠ¶æ€é€‰æ‹©åˆé€‚çš„ç¼“å­˜ï¼‰
                        if (!forceOriginal && imageCache.has(cacheKey)) {
                            const cachedUrl = imageCache.get(cacheKey);
                            imageUrls.push(cachedUrl);

                            // æ›´æ–°ç¼“å­˜è®¿é—®è®°å½•
                            updateCacheAccess(cacheKey);

                            console.log(`ğŸ’¾ [${timestamp}] é¡µé¢ ${pageNum + 1} ä»${expectedType}ç¼“å­˜åŠ è½½ (é”®: ${cacheKey})`);
                            continue;
                        }

                        // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œ
                        const requestKey = `page_${mangaPath}_${pageNum}_${expectedType}${forceOriginal ? '_force' : ''}`;
                        if (pendingPageRequests.has(requestKey)) {
                            console.log(`â³ [${timestamp}] é¡µé¢ ${pageNum + 1} è¯·æ±‚æ­£åœ¨è¿›è¡Œä¸­ï¼Œç­‰å¾…ç»“æœ`);
                            try {
                                const imageUrl = await pendingPageRequests.get(requestKey);
                                imageUrls.push(imageUrl);
                                continue;
                            } catch (error) {
                                console.error(`âŒ [${timestamp}] ç­‰å¾…é¡µé¢ ${pageNum + 1} è¯·æ±‚å¤±è´¥:`, error);
                                break;
                            }
                        }

                        // åˆ›å»ºæ–°çš„è¯·æ±‚
                        console.log(`ğŸš€ [${timestamp}] å‘èµ·æ–°è¯·æ±‚: é¡µé¢${pageNum + 1}, ç±»å‹=${expectedType}`);
                        const requestPromise = loadSinglePage(mangaPath, pageNum, forceOriginal);
                        pendingPageRequests.set(requestKey, requestPromise);

                        try {
                            const imageUrl = await requestPromise;
                            if (imageUrl) {
                                imageUrls.push(imageUrl);

                                // ç¼“å­˜åˆ°æ­£ç¡®çš„é”®å€¼
                                if (!forceOriginal) {
                                    imageCache.set(cacheKey, imageUrl);

                                    // è®°å½•ç¼“å­˜å…ƒæ•°æ®
                                    const metadata = {
                                        timestamp: Date.now(),
                                        lastAccess: Date.now(),
                                        accessCount: 1,
                                        type: expectedType,
                                        pageNum: pageNum
                                    };
                                    cacheMetadata.set(cacheKey, metadata);

                                    console.log(`ğŸ’¾ [${timestamp}] é¡µé¢ ${pageNum + 1} å·²ç¼“å­˜åˆ°${expectedType}ç¼“å­˜ (é”®: ${cacheKey}, æ€»ç¼“å­˜: ${imageCache.size})`);
                                } else {
                                    console.log(`ğŸ“„ [${timestamp}] é¡µé¢ ${pageNum + 1} å¼ºåˆ¶åŸå§‹æ¨¡å¼ï¼Œä¸ç¼“å­˜`);
                                }
                            } else {
                                console.warn(`âš ï¸ [${timestamp}] é¡µé¢ ${pageNum + 1} æ•°æ®æ— æ•ˆ`);
                                break;
                            }
                        } catch (error) {
                            console.error(`âŒ [${timestamp}] åŠ è½½é¡µé¢ ${pageNum + 1} å¤±è´¥:`, error);
                            break;
                        } finally {
                            pendingPageRequests.delete(requestKey);
                        }
                    }

                    console.log(`âœ… [${timestamp}] é¡µé¢åŠ è½½å®Œæˆ: æˆåŠŸ${imageUrls.length}/${count}é¡µ`);
                    return imageUrls;
                }

                // ç”Ÿæˆç¼“å­˜é”®å€¼çš„ç»Ÿä¸€å‡½æ•°
                function generateCacheKey(mangaPath, pageNum, type = 'original') {
                    // ä½¿ç”¨ä¸åŒçš„å‰ç¼€ç¡®ä¿ç¿»è¯‘ç¼“å­˜å’ŒåŸå§‹ç¼“å­˜å®Œå…¨åˆ†ç¦»
                    const prefix = type === 'translated' ? 'TRANS' : 'ORIG';
                    return `${prefix}_${mangaPath}_${pageNum}`;
                }

                // ç»Ÿä¸€çš„é¡µé¢è·å–æœºåˆ¶ï¼ˆå››å±‚ç¼“å­˜æ¶æ„ç‰ˆæœ¬ï¼‰
                async function getPageImage(mangaPath, pageNum, forceOriginal = false) {
                    const timestamp = new Date().toLocaleTimeString();
                    console.log(`ğŸ” [${timestamp}] å››å±‚ç¼“å­˜æ¶æ„: è·å–é¡µé¢å›¾åƒ é¡µé¢${pageNum + 1}, å¼ºåˆ¶åŸå§‹=${forceOriginal}, ç¿»è¯‘å¯ç”¨=${translationEnabled.value}`);

                    // å†³å®šè¿”å›å“ªä¸ªç‰ˆæœ¬çš„é¡µé¢
                    const shouldUseTranslation = translationEnabled.value && !forceOriginal && window.realtimeTranslation;

                    if (shouldUseTranslation) {
                        console.log(`ğŸ“ [${timestamp}] å››å±‚ç¼“å­˜æ¶æ„: å°è¯•è·å–ç¿»è¯‘ç‰ˆæœ¬ é¡µé¢${pageNum + 1}`);

                        // 1. æ£€æŸ¥å‰ç«¯ç¿»è¯‘é¡µé¢ç¼“å­˜ï¼ˆå†…å­˜base64ï¼‰
                        const translationCacheKey = `TRANS_${mangaPath}:${pageNum}`;
                        if (window.realtimeTranslation && window.realtimeTranslation.translatedPages &&
                            window.realtimeTranslation.translatedPages.has(translationCacheKey)) {
                            const cachedImage = window.realtimeTranslation.translatedPages.get(translationCacheKey);
                            console.log(`ğŸ’¾ [${timestamp}] é¡µé¢${pageNum + 1}å‰ç«¯ç¿»è¯‘ç¼“å­˜å‘½ä¸­ï¼ˆå†…å­˜base64ï¼‰`);
                            return {
                                imageData: `data:image/jpeg;base64,${cachedImage}`,
                                isTranslated: true,
                                source: 'frontend_translation_cache'
                            };
                        }

                        // 2-4. é€šè¿‡å®æ—¶ç¿»è¯‘æ¨¡å—æ£€æŸ¥åç«¯ä¸‰å±‚ç¼“å­˜
                        try {
                            const translatedImage = await window.realtimeTranslation.getTranslatedPage(mangaPath, pageNum);
                            if (translatedImage) {
                                console.log(`âœ… [${timestamp}] é¡µé¢${pageNum + 1}ä½¿ç”¨ç¿»è¯‘ç»“æœ (æ¥æº: åç«¯ç¼“å­˜)`);
                                // ç¿»è¯‘ç»“æœæ˜¯WebPæˆ–JPEGæ ¼å¼çš„base64æ•°æ®ï¼Œæ·»åŠ æ­£ç¡®çš„data URLå‰ç¼€
                                return {
                                    imageData: `data:image/jpeg;base64,${translatedImage}`,
                                    isTranslated: true,
                                    source: 'backend_translation_cache'
                                };
                            } else {
                                console.log(`âš ï¸ [${timestamp}] é¡µé¢${pageNum + 1}ç¿»è¯‘ç»“æœä¸ºç©ºï¼Œå›é€€åˆ°åŸå§‹å›¾åƒ`);
                            }
                        } catch (error) {
                            console.warn(`âŒ [${timestamp}] è·å–é¡µé¢${pageNum + 1}ç¿»è¯‘ç»“æœå¤±è´¥:`, error);
                        }
                    } else {
                        console.log(`ğŸ“„ [${timestamp}] ç›´æ¥è·å–åŸå§‹å›¾åƒ: é¡µé¢${pageNum + 1} (ç¿»è¯‘=${translationEnabled.value}, å¼ºåˆ¶=${forceOriginal})`);
                    }

                    // è·å–åŸå§‹å›¾åƒï¼ˆç¬¬å››å±‚ï¼šåç«¯åŸå§‹æ¼«ç”»ç¼“å­˜ï¼‰
                    try {
                        const response = await axios.post('/api/manga/viewer/page', {
                            manga_path: mangaPath,
                            page_num: pageNum
                        });

                        if (response.data && response.data.image) {
                            console.log(`âœ… [${timestamp}] é¡µé¢${pageNum + 1}ä½¿ç”¨åŸå§‹å›¾åƒ (æ¥æº: åç«¯åŸå§‹æ¼«ç”»ç¼“å­˜)`);
                            return {
                                imageData: response.data.image,
                                isTranslated: false,
                                source: 'backend_original_cache'
                            };
                        } else {
                            throw new Error(`é¡µé¢ ${pageNum + 1} æ•°æ®æ— æ•ˆ`);
                        }
                    } catch (error) {
                        console.error(`âŒ [${timestamp}] è·å–é¡µé¢${pageNum + 1}åŸå§‹å›¾åƒå¤±è´¥:`, error);
                        throw error;
                    }
                }

                // åŠ è½½å•ä¸ªé¡µé¢çš„å‡½æ•°ï¼ˆä½¿ç”¨ç»Ÿä¸€æœºåˆ¶ï¼‰
                async function loadSinglePage(mangaPath, pageNum, forceOriginal = false) {
                    const result = await getPageImage(mangaPath, pageNum, forceOriginal);
                    return result.imageData;
                }

                async function loadCurrentPage(forceOriginal = false) {
                    try {
                        const mode = actualDisplayMode.value;
                        const pagesToLoad = mode === 'double' ? 2 : 1;

                        // åŠ è½½å½“å‰é¡µé¢
                        const imageUrls = await loadPageImages(currentPage.value, pagesToLoad, forceOriginal);

nextTick(() => {
                                if (viewerContent.value) {
                                    console.log('.viewer-content (after load) å°ºå¯¸:', viewerContent.value.offsetWidth, 'x', viewerContent.value.offsetHeight);
                                }
                                const imageContainer = document.querySelector('.image-container');
                                if (imageContainer) {
                                    console.log('.image-container å°ºå¯¸:', imageContainer.offsetWidth, 'x', imageContainer.offsetHeight);
                                }
                                const mangaImages = document.querySelectorAll('.manga-image');
                                mangaImages.forEach((img, index) => {
                                    console.log(`å›¾ç‰‡ ${index + 1} (.manga-image) æ¸²æŸ“å°ºå¯¸:`, img.offsetWidth, 'x', img.offsetHeight);
                                });
                            });
                        if (imageUrls.length > 0) {
                            // åªæœ‰åœ¨æ–°å›¾ç‰‡åŠ è½½å®Œæˆåæ‰æ›´æ–°æ˜¾ç¤º
                            currentImageUrls.value = imageUrls;
                            console.log(`${mode}æ¨¡å¼åŠ è½½å®Œæˆï¼Œå…± ${imageUrls.length} é¡µ`);

                            // é¢„åŠ è½½ä¸‹ä¸€ç»„é¡µé¢ï¼ˆåå°è¿›è¡Œï¼Œä¸é˜»å¡å½“å‰æ˜¾ç¤ºï¼‰
                            preloadNextPages();
                        } else {
                            throw new Error('æ— æ³•åŠ è½½ä»»ä½•å›¾ç‰‡');
                        }

                    } catch (error) {
                        console.error('åŠ è½½é¡µé¢å¤±è´¥:', error);
                        ElMessage.error(`åŠ è½½ç¬¬ ${currentPage.value + 1} é¡µå¤±è´¥`);
                        // å‘ç”Ÿé”™è¯¯æ—¶ä¸æ¸…ç©ºå½“å‰å›¾ç‰‡ï¼Œä¿æŒæ˜¾ç¤º
                    }
                }

                // æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥é…ç½®
                const preloadConfig = {
                    // åŸºç¡€é¢„åŠ è½½èŒƒå›´ï¼ˆç›¸é‚»é¡µé¢ï¼‰
                    immediate: {
                        single: 1,  // å•é¡µæ¨¡å¼ï¼šå½“å‰é¡µ + ä¸‹1é¡µ
                        double: 2   // åŒé¡µæ¨¡å¼ï¼šå½“å‰2é¡µ + ä¸‹2é¡µ
                    },
                    // æ¸è¿›å¼é¢„åŠ è½½èŒƒå›´
                    progressive: {
                        single: 3,  // å•é¡µæ¨¡å¼ï¼šå†é¢„åŠ è½½å‰å3é¡µ
                        double: 4   // åŒé¡µæ¨¡å¼ï¼šå†é¢„åŠ è½½å‰å4é¡µ
                    },
                    // é¢„åŠ è½½å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
                    delays: {
                        immediate: 100,    // ç«‹å³é¢„åŠ è½½å»¶è¿Ÿ
                        progressive: 1000  // æ¸è¿›å¼é¢„åŠ è½½å»¶è¿Ÿ
                    }
                };

                async function preloadNextPages() {
                    const timestamp = new Date().toLocaleTimeString();
                    const mode = actualDisplayMode.value;
                    const currentPageNum = currentPage.value;

                    console.log(`ğŸ”„ [${timestamp}] å¼€å§‹æ™ºèƒ½é¢„åŠ è½½: å½“å‰é¡µ${currentPageNum + 1}, æ¨¡å¼=${mode}`);

                    try {
                        // ç¬¬ä¸€é˜¶æ®µï¼šç«‹å³é¢„åŠ è½½ç›¸é‚»é¡µé¢
                        await immediatePreload(mode, currentPageNum);

                        // ç¬¬äºŒé˜¶æ®µï¼šå»¶è¿Ÿæ¸è¿›å¼é¢„åŠ è½½
                        setTimeout(() => {
                            progressivePreload(mode, currentPageNum);
                        }, preloadConfig.delays.progressive);

                    } catch (error) {
                        console.warn(`âš ï¸ [${timestamp}] é¢„åŠ è½½å¤±è´¥:`, error);
                    }
                }

                // ç«‹å³é¢„åŠ è½½ç›¸é‚»é¡µé¢
                async function immediatePreload(mode, currentPageNum) {
                    const timestamp = new Date().toLocaleTimeString();
                    const range = preloadConfig.immediate[mode];

                    // è®¡ç®—éœ€è¦é¢„åŠ è½½çš„é¡µé¢
                    const pagesToPreload = [];

                    // é¢„åŠ è½½ä¸‹ä¸€ç»„é¡µé¢ï¼ˆç”¨æˆ·æœ€å¯èƒ½è®¿é—®çš„ï¼‰
                    for (let i = 1; i <= range; i++) {
                        const nextPage = currentPageNum + i;
                        if (nextPage < mangaInfo.total_pages) {
                            pagesToPreload.push(nextPage);
                        }
                    }

                    console.log(`âš¡ [${timestamp}] ç«‹å³é¢„åŠ è½½: é¡µé¢${pagesToPreload.map(p => p + 1).join(', ')}`);

                    // å¹¶å‘é¢„åŠ è½½ï¼Œä½†é™åˆ¶å¹¶å‘æ•°
                    const concurrentLimit = 2;
                    for (let i = 0; i < pagesToPreload.length; i += concurrentLimit) {
                        const batch = pagesToPreload.slice(i, i + concurrentLimit);

                        await Promise.allSettled(
                            batch.map(pageNum => preloadSinglePage(pageNum))
                        );

                        // æ‰¹æ¬¡é—´çŸ­æš‚å»¶è¿Ÿ
                        if (i + concurrentLimit < pagesToPreload.length) {
                            await new Promise(resolve => setTimeout(resolve, preloadConfig.delays.immediate));
                        }
                    }
                }

                // æ¸è¿›å¼é¢„åŠ è½½
                async function progressivePreload(mode, currentPageNum) {
                    const timestamp = new Date().toLocaleTimeString();
                    const range = preloadConfig.progressive[mode];

                    // è®¡ç®—æ¸è¿›å¼é¢„åŠ è½½èŒƒå›´
                    const pagesToPreload = [];

                    // å‘å‰é¢„åŠ è½½
                    for (let i = 1; i <= range; i++) {
                        const prevPage = currentPageNum - i;
                        if (prevPage >= 0) {
                            pagesToPreload.push(prevPage);
                        }
                    }

                    // å‘åé¢„åŠ è½½ï¼ˆè·³è¿‡å·²ç»åœ¨ç«‹å³é¢„åŠ è½½ä¸­çš„é¡µé¢ï¼‰
                    const immediateRange = preloadConfig.immediate[mode];
                    for (let i = immediateRange + 1; i <= range; i++) {
                        const nextPage = currentPageNum + i;
                        if (nextPage < mangaInfo.total_pages) {
                            pagesToPreload.push(nextPage);
                        }
                    }

                    if (pagesToPreload.length === 0) {
                        console.log(`â„¹ï¸ [${timestamp}] æ— éœ€æ¸è¿›å¼é¢„åŠ è½½`);
                        return;
                    }

                    console.log(`ğŸ”® [${timestamp}] æ¸è¿›å¼é¢„åŠ è½½: é¡µé¢${pagesToPreload.map(p => p + 1).join(', ')}`);

                    // ä½ä¼˜å…ˆçº§é¢„åŠ è½½ï¼Œæ›´é•¿çš„å»¶è¿Ÿ
                    for (const pageNum of pagesToPreload) {
                        setTimeout(() => {
                            preloadSinglePage(pageNum, true); // æ ‡è®°ä¸ºä½ä¼˜å…ˆçº§
                        }, Math.random() * 2000); // éšæœºå»¶è¿Ÿ0-2ç§’
                    }
                }

                // é¢„åŠ è½½å•ä¸ªé¡µé¢
                async function preloadSinglePage(pageNum, lowPriority = false) {
                    const timestamp = new Date().toLocaleTimeString();
                    const expectedType = (translationEnabled.value) ? 'translated' : 'original';
                    const cacheKey = generateCacheKey(mangaPath, pageNum, expectedType);

                    // æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜
                    if (imageCache.has(cacheKey)) {
                        console.log(`ğŸ’¾ [${timestamp}] é¡µé¢${pageNum + 1}å·²ç¼“å­˜ï¼Œè·³è¿‡é¢„åŠ è½½`);
                        return;
                    }

                    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
                    const requestKey = `page_${mangaPath}_${pageNum}_${expectedType}_preload`;
                    if (pendingPageRequests.has(requestKey)) {
                        console.log(`â³ [${timestamp}] é¡µé¢${pageNum + 1}æ­£åœ¨é¢„åŠ è½½ä¸­`);
                        return;
                    }

                    try {
                        const priority = lowPriority ? 'ä½' : 'é«˜';
                        console.log(`ğŸš€ [${timestamp}] é¢„åŠ è½½é¡µé¢${pageNum + 1} (ä¼˜å…ˆçº§: ${priority})`);

                        const requestPromise = loadSinglePage(mangaPath, pageNum);
                        pendingPageRequests.set(requestKey, requestPromise);

                        const imageUrl = await requestPromise;
                        if (imageUrl) {
                            imageCache.set(cacheKey, imageUrl);
                            console.log(`âœ… [${timestamp}] é¡µé¢${pageNum + 1}é¢„åŠ è½½å®Œæˆ`);

                            // å¦‚æœå¯ç”¨ç¿»è¯‘ä¸”è¿™æ˜¯åŸå§‹é¡µé¢ï¼Œè¯·æ±‚ç¿»è¯‘
                            if (translationEnabled.value && window.realtimeTranslation && expectedType === 'original') {
                                setTimeout(() => {
                                    window.realtimeTranslation.requestTranslation(
                                        mangaInfo.file_path,
                                        pageNum,
                                        lowPriority ? 2 : 5
                                    );
                                }, lowPriority ? 2000 : 500);
                            }
                        }
                    } catch (error) {
                        console.warn(`âš ï¸ [${timestamp}] é¡µé¢${pageNum + 1}é¢„åŠ è½½å¤±è´¥:`, error);
                    } finally {
                        pendingPageRequests.delete(requestKey);
                    }
                }

                // ==================== é¡µé¢æ§åˆ¶ ====================

                function previousPage() {
                    const step = actualDisplayMode.value === 'double' ? 2 : 1;
                    if (currentPage.value > 0) {
                        const newPage = Math.max(0, currentPage.value - step);
                        onPageChange(newPage);
                    }
                }

                function nextPage() {
                    const step = actualDisplayMode.value === 'double' ? 2 : 1;
                    if (currentPage.value < mangaInfo.total_pages - 1) {
                        const newPage = Math.min(mangaInfo.total_pages - 1, currentPage.value + step);
                        onPageChange(newPage);
                    }
                }

                async function onPageChange(newPage) {
                    const timestamp = new Date().toLocaleTimeString();
                    console.log(`ğŸ“– [${timestamp}] é¡µé¢åˆ‡æ¢: ${currentPage.value + 1} â†’ ${newPage + 1}`);

                    currentPage.value = newPage;
                    pageInputText.value = (newPage + 1).toString(); // åŒæ­¥æ›´æ–°è¾“å…¥æ¡†æ–‡æœ¬

                    // å…ˆåŠ è½½å½“å‰é¡µé¢
                    await loadCurrentPage();

                    // å¦‚æœå¯ç”¨äº†ç¿»è¯‘ï¼Œæ™ºèƒ½è¯·æ±‚ç¿»è¯‘
                    if (translationEnabled.value && window.realtimeTranslation) {
                        await requestTranslationForCurrentView(newPage);
                    } else {
                        console.log(`â„¹ï¸ [${timestamp}] ç¿»è¯‘æœªå¯ç”¨ï¼Œè·³è¿‡ç¿»è¯‘è¯·æ±‚`);
                    }
                }

                // ä¸ºå½“å‰è§†å›¾è¯·æ±‚ç¿»è¯‘ï¼ˆä¸é¢„åŠ è½½ç­–ç•¥ä¿æŒä¸€è‡´ï¼‰
                async function requestTranslationForCurrentView(currentPageNum) {
                    const timestamp = new Date().toLocaleTimeString();
                    const mode = actualDisplayMode.value;

                    try {
                        // ç¿»è¯‘è¯·æ±‚èŒƒå›´ä¸é¢„åŠ è½½èŒƒå›´ä¿æŒä¸€è‡´
                        const immediateRange = preloadConfig.immediate[mode];
                        const progressiveRange = preloadConfig.progressive[mode];

                        // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šå½“å‰æ˜¾ç¤ºçš„é¡µé¢
                        const currentPages = [];
                        const pagesInView = mode === 'double' ? 2 : 1;
                        for (let i = 0; i < pagesInView; i++) {
                            const pageNum = currentPageNum + i;
                            if (pageNum < mangaInfo.total_pages) {
                                currentPages.push(pageNum);
                            }
                        }

                        if (currentPages.length > 0) {
                            console.log(`ğŸ”¥ [${timestamp}] é«˜ä¼˜å…ˆçº§ç¿»è¯‘è¯·æ±‚: å½“å‰é¡µé¢${currentPages.map(p => p + 1).join(', ')}`);
                            await window.realtimeTranslation.requestTranslation(
                                mangaInfo.file_path,
                                currentPages,
                                10  // æœ€é«˜ä¼˜å…ˆçº§
                            );
                        }

                        // ç¬¬äºŒä¼˜å…ˆçº§ï¼šç«‹å³é¢„åŠ è½½èŒƒå›´
                        const immediatePages = [];
                        for (let i = 1; i <= immediateRange; i++) {
                            const nextPage = currentPageNum + i;
                            if (nextPage < mangaInfo.total_pages) {
                                immediatePages.push(nextPage);
                            }
                        }

                        if (immediatePages.length > 0) {
                            setTimeout(async () => {
                                console.log(`âš¡ [${timestamp}] ä¸­ä¼˜å…ˆçº§ç¿»è¯‘è¯·æ±‚: ç›¸é‚»é¡µé¢${immediatePages.map(p => p + 1).join(', ')}`);
                                await window.realtimeTranslation.requestTranslation(
                                    mangaInfo.file_path,
                                    immediatePages,
                                    7  // é«˜ä¼˜å…ˆçº§
                                );
                            }, 200);
                        }

                        // ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šæ¸è¿›å¼é¢„åŠ è½½èŒƒå›´ï¼ˆå»¶è¿Ÿè¯·æ±‚ï¼‰
                        setTimeout(async () => {
                            const progressivePages = [];

                            // å‘å‰
                            for (let i = 1; i <= progressiveRange; i++) {
                                const prevPage = currentPageNum - i;
                                if (prevPage >= 0) {
                                    progressivePages.push(prevPage);
                                }
                            }

                            // å‘åï¼ˆè·³è¿‡å·²è¯·æ±‚çš„ç«‹å³èŒƒå›´ï¼‰
                            for (let i = immediateRange + 1; i <= progressiveRange; i++) {
                                const nextPage = currentPageNum + i;
                                if (nextPage < mangaInfo.total_pages) {
                                    progressivePages.push(nextPage);
                                }
                            }

                            if (progressivePages.length > 0) {
                                console.log(`ğŸ”® [${timestamp}] ä½ä¼˜å…ˆçº§ç¿»è¯‘è¯·æ±‚: æ‰©å±•é¡µé¢${progressivePages.map(p => p + 1).join(', ')}`);

                                // åˆ†æ‰¹è¯·æ±‚ï¼Œé¿å…ä¸€æ¬¡æ€§è¯·æ±‚è¿‡å¤š
                                const batchSize = 3;
                                for (let i = 0; i < progressivePages.length; i += batchSize) {
                                    const batch = progressivePages.slice(i, i + batchSize);

                                    setTimeout(async () => {
                                        try {
                                            await window.realtimeTranslation.requestTranslation(
                                                mangaInfo.file_path,
                                                batch,
                                                3  // ä½ä¼˜å…ˆçº§
                                            );
                                        } catch (error) {
                                            console.warn(`âš ï¸ [${timestamp}] ä½ä¼˜å…ˆçº§ç¿»è¯‘è¯·æ±‚å¤±è´¥:`, error);
                                        }
                                    }, i * 300); // æ¯æ‰¹é—´éš”300ms
                                }
                            }
                        }, 1000); // å»¶è¿Ÿ1ç§’åè¯·æ±‚ä½ä¼˜å…ˆçº§ç¿»è¯‘

                    } catch (error) {
                        console.error(`âŒ [${timestamp}] ç¿»è¯‘è¯·æ±‚å¤±è´¥:`, error);
                    }
                }

                // é¡µç è¾“å…¥ç›¸å…³æ–¹æ³•
                function onPageInputEnter() {
                    applyPageInput();
                }

                function onPageInputBlur() {
                    applyPageInput();
                }

                function cancelPageInput() {
                    showPageInput.value = false;
                    pageInputText.value = (currentPage.value + 1).toString(); // æ¢å¤åŸå€¼
                }

                function applyPageInput() {
                    const newPage = parseInt(pageInputText.value);
                    if (newPage && newPage >= 1 && newPage <= mangaInfo.total_pages) {
                        currentPage.value = newPage - 1; // è½¬æ¢ä¸º0-based
                        loadCurrentPage();
                    } else {
                        // è¾“å…¥æ— æ•ˆï¼Œæ¢å¤åŸå€¼
                        pageInputText.value = (currentPage.value + 1).toString();
                    }
                    showPageInput.value = false;
                }

                // ==================== è‡ªå®šä¹‰æ»‘å—æ–¹æ³• ====================

                function onThumbMouseDown(event) {
                    isDragging.value = true;
                    const thumb = event.target;
                    const container = sliderContainer.value;
                    const initialY = event.clientY;
                    const initialTop = thumb.offsetTop;

                    const onMouseMove = (moveEvent) => {
                        if (!isDragging.value) return;

                        const deltaY = moveEvent.clientY - initialY;
                        let newTop = initialTop + deltaY;

                        const containerHeight = container.offsetHeight;
                        const thumbHeight = thumb.offsetHeight;
                        
                        // é™åˆ¶åœ¨è½¨é“å†…
                        newTop = Math.max(0, Math.min(newTop, containerHeight - thumbHeight));
                        
                        const percentage = newTop / (containerHeight - thumbHeight);
                        const newPage = Math.round(percentage * (mangaInfo.total_pages - 1));
                        
                        // ä»…æ›´æ–°é¢„è§ˆé¡µç ï¼Œä¸ç«‹å³è·³è½¬
                        pageInputText.value = (newPage + 1).toString();
                        
                        // ç›´æ¥æ›´æ–°æ ·å¼ä»¥è·å¾—å³æ—¶åé¦ˆ
                        thumb.style.top = `${newTop}px`;
                    };

                    const onMouseUp = () => {
                        isDragging.value = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);

                        // æ‹–åŠ¨ç»“æŸåï¼Œæ ¹æ®æœ€ç»ˆä½ç½®è®¡ç®—å¹¶è·³è½¬é¡µé¢
                        const finalPercentage = thumb.offsetTop / (container.offsetHeight - thumb.offsetHeight);
                        const finalPage = Math.round(finalPercentage * (mangaInfo.total_pages - 1));
                        if (finalPage !== currentPage.value) {
                            onPageChange(finalPage);
                        }
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                }

                function onTrackClick(event) {
                    if (isDragging.value) return;

                    const container = sliderContainer.value;
                    const rect = container.getBoundingClientRect();
                    const clickY = event.clientY - rect.top;
                    
                    const containerHeight = container.offsetHeight;
                    const thumbHeight = 30; // ç¡¬ç¼–ç ä¸CSSä¸€è‡´
                    
                    let percentage = clickY / containerHeight;
                    // è°ƒæ•´ï¼Œä½¿ç‚¹å‡»ä¸­å¿ƒå¤§è‡´å¯¹é½æ»‘å—ä¸­å¿ƒ
                    percentage = (clickY - (thumbHeight / 2)) / (containerHeight - thumbHeight);
                    percentage = Math.max(0, Math.min(1, percentage));

                    const newPage = Math.round(percentage * (mangaInfo.total_pages - 1));
                    
                    if (newPage !== currentPage.value) {
                        onPageChange(newPage);
                    }
                }
                
                // ç›‘å¬é¡µç è¾“å…¥æ¡†æ˜¾ç¤ºçŠ¶æ€ï¼Œè‡ªåŠ¨èšç„¦
                watch(showPageInput, (newValue) => {
                    if (newValue) {
                        nextTick(() => {
                            if (pageInputRef.value) {
                                pageInputRef.value.focus();
                                pageInputRef.value.select(); // é€‰ä¸­æ‰€æœ‰æ–‡æœ¬
                            }
                        });
                    }
                });

                function toggleDisplayMode() {
                    if (displayMode.value === 'auto') {
                        displayMode.value = 'single';
                    } else if (displayMode.value === 'single') {
                        displayMode.value = 'double';
                    } else {
                        displayMode.value = 'auto';
                    }
                    loadCurrentPage();
const img = event.target;
                    console.log(`å›¾ç‰‡åŠ è½½å®Œæˆ - src: ${img.src}`);
                    console.log(`å›¾ç‰‡è‡ªç„¶å°ºå¯¸: ${img.naturalWidth} x ${img.naturalHeight}`);
                    console.log(`å›¾ç‰‡æ¸²æŸ“å°ºå¯¸: ${img.offsetWidth} x ${img.offsetHeight}`);
const computedStyle = window.getComputedStyle(img);
                    console.log('å›¾ç‰‡è®¡ç®—æ ·å¼:', {
                        width: computedStyle.width,
                        height: computedStyle.height,
                        maxWidth: computedStyle.maxWidth,
                        maxHeight: computedStyle.maxHeight,
                        objectFit: computedStyle.objectFit,
                    });

                    const doublePage = img.closest('.double-page');
                    if (doublePage) {
                        const dpStyle = window.getComputedStyle(doublePage);
                        console.log('.double-page å°ºå¯¸:', doublePage.offsetWidth, 'x', doublePage.offsetHeight);
                        console.log('.double-page è®¡ç®—æ ·å¼:', {
                            width: dpStyle.width,
                            height: dpStyle.height,
                            maxWidth: dpStyle.maxWidth,
                            maxHeight: dpStyle.maxHeight,
                        });
                    }

                    const doublePageContainer = img.closest('.double-page-container');
                    if (doublePageContainer) {
                        const dpcStyle = window.getComputedStyle(doublePageContainer);
                        console.log('.double-page-container å°ºå¯¸:', doublePageContainer.offsetWidth, 'x', doublePageContainer.offsetHeight);
                        console.log('.double-page-container è®¡ç®—æ ·å¼:', {
                            width: dpcStyle.width,
                            height: dpcStyle.height,
                            maxWidth: dpcStyle.maxWidth,
                            maxHeight: dpcStyle.maxHeight,
                        });
                    }
                }

                async function toggleTranslation() {
                    const currentState = translationEnabled.value;
                    const newState = !currentState;
                    const timestamp = new Date().toLocaleTimeString();

                    console.log(`ğŸ”„ [${timestamp}] ç¿»è¯‘æŒ‰é’®ç‚¹å‡»: ${currentState} -> ${newState}`);

                    if (newState) {
                        // å¯ç”¨ç¿»è¯‘
                        try {
                            // æ£€æŸ¥ç¿»è¯‘æ¨¡å—æ˜¯å¦å¯ç”¨
                            if (!window.realtimeTranslation) {
                                throw new Error('å®æ—¶ç¿»è¯‘æ¨¡å—æœªåˆå§‹åŒ–');
                            }

                            console.log(`ğŸš€ [${timestamp}] å¯åŠ¨å®æ—¶ç¿»è¯‘æœåŠ¡...`);
                            const success = await window.realtimeTranslation.startService();

                            if (success) {
                                // åªæœ‰æœåŠ¡å¯åŠ¨æˆåŠŸåæ‰æ›´æ–°çŠ¶æ€
                                translationEnabled.value = true;
                                console.log(`âœ… [${timestamp}] ç¿»è¯‘çŠ¶æ€å·²æ›´æ–°ä¸º: ${translationEnabled.value}`);
                                ElMessage.success('å®æ—¶ç¿»è¯‘å·²å¯ç”¨');

                                // è®¾ç½®ç¿»è¯‘å®Œæˆå›è°ƒ
                                window.realtimeTranslation.onTranslationCompleted = (mangaPath, pageIndex, imageData) => {
                                    console.log(`ğŸ”” [${timestamp}] ç¿»è¯‘å®Œæˆå›è°ƒ: é¡µé¢ ${pageIndex + 1}`);

                                    // å¦‚æœæ˜¯å½“å‰æ˜¾ç¤ºçš„é¡µé¢ï¼Œåˆ·æ–°æ˜¾ç¤º
                                    if (mangaPath === mangaInfo.file_path && translationEnabled.value) {
                                        const mode = actualDisplayMode.value;
                                        const currentPageNum = currentPage.value;

                                        // æ¸…é™¤ç›¸å…³é¡µé¢çš„ç¼“å­˜
                                        clearPageCache(pageIndex);

                                        // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰æ˜¾ç¤ºçš„é¡µé¢
                                        if (mode === 'single' && pageIndex === currentPageNum) {
                                            console.log(`ğŸ”„ [${timestamp}] åˆ·æ–°å½“å‰é¡µé¢æ˜¾ç¤º: ${pageIndex + 1}`);
                                            loadCurrentPage();
                                        } else if (mode === 'double' && (pageIndex === currentPageNum || pageIndex === currentPageNum + 1)) {
                                            console.log(`ğŸ”„ [${timestamp}] åˆ·æ–°åŒé¡µæ˜¾ç¤º: ${pageIndex + 1}`);
                                            loadCurrentPage();
                                        }
                                    }
                                };

                                // è®¾ç½®å½“å‰æ¼«ç”»
                                await window.realtimeTranslation.setCurrentManga(
                                    mangaInfo.file_path,
                                    currentPage.value
                                );

                                // è¯·æ±‚ç¿»è¯‘å½“å‰é¡µé¢å’Œå‘¨å›´é¡µé¢
                                const pagesToTranslate = [];
                                for (let i = Math.max(0, currentPage.value - 2);
                                     i <= Math.min(mangaInfo.total_pages - 1, currentPage.value + 2);
                                     i++) {
                                    pagesToTranslate.push(i);
                                }

                                await window.realtimeTranslation.requestTranslation(
                                    mangaInfo.file_path,
                                    pagesToTranslate,
                                    5  // é«˜ä¼˜å…ˆçº§
                                );

                                // åˆ·æ–°å·²ç¿»è¯‘çš„é¡µé¢
                                setTimeout(() => {
                                    refreshTranslatedPages();
                                }, 2000);

                                console.log(`âœ… [${timestamp}] å®æ—¶ç¿»è¯‘æœåŠ¡å¯åŠ¨æˆåŠŸ`);
                            } else {
                                throw new Error('å¯åŠ¨ç¿»è¯‘æœåŠ¡å¤±è´¥');
                            }
                        } catch (error) {
                            console.error(`âŒ [${timestamp}] å¯åŠ¨ç¿»è¯‘æœåŠ¡å¤±è´¥:`, error);
                            ElMessage.error('å¯åŠ¨ç¿»è¯‘æœåŠ¡å¤±è´¥: ' + error.message);
                            // ç¡®ä¿çŠ¶æ€ä¿æŒä¸ºå…³é—­
                            translationEnabled.value = false;
                            console.log(`ğŸ”„ [${timestamp}] ç¿»è¯‘çŠ¶æ€å›æ»šä¸º: ${translationEnabled.value}`);
                        }
                    } else {
                        // å…³é—­ç¿»è¯‘
                        try {
                            console.log(`ğŸ›‘ [${timestamp}] å…³é—­ç¿»è¯‘åŠŸèƒ½...`);

                            // å…ˆæ›´æ–°çŠ¶æ€ï¼Œç¡®ä¿åç»­æ“ä½œä½¿ç”¨åŸå§‹å›¾åƒ
                            translationEnabled.value = false;
                            console.log(`âœ… [${timestamp}] ç¿»è¯‘çŠ¶æ€å·²æ›´æ–°ä¸º: ${translationEnabled.value}`);

                            // åœæ­¢ç¿»è¯‘æœåŠ¡
                            if (window.realtimeTranslation) {
                                await window.realtimeTranslation.stopService();
                            }

                            // æ¸…é™¤ç¿»è¯‘ç›¸å…³ç¼“å­˜
                            const clearedCount = clearTranslationCache();

                            // é‡æ–°åŠ è½½å½“å‰é¡µé¢ï¼ˆå¼ºåˆ¶ä½¿ç”¨åŸå§‹å›¾åƒï¼‰
                            await loadCurrentPage(true);

                            ElMessage.info('å®æ—¶ç¿»è¯‘å·²å…³é—­');
                            console.log(`âœ… [${timestamp}] ç¿»è¯‘åŠŸèƒ½å·²å…³é—­ï¼Œå·²åˆ‡æ¢åˆ°åŸå§‹å›¾åƒï¼Œæ¸…é™¤ç¼“å­˜${clearedCount}é¡¹`);

                        } catch (error) {
                            console.error(`âŒ [${timestamp}] åœæ­¢ç¿»è¯‘æœåŠ¡å¤±è´¥:`, error);
                            ElMessage.warning('åœæ­¢ç¿»è¯‘æœåŠ¡å¤±è´¥: ' + error.message);
                            // å³ä½¿åœæ­¢å¤±è´¥ï¼Œä¹Ÿè¦ç¡®ä¿çŠ¶æ€æ­£ç¡®
                            translationEnabled.value = false;
                            console.log(`ğŸ”„ [${timestamp}] ç¿»è¯‘çŠ¶æ€å¼ºåˆ¶è®¾ä¸º: ${translationEnabled.value}`);
                            clearTranslationCache();
                            await loadCurrentPage(true);
                        }
                    }

                    // å¼ºåˆ¶è§¦å‘Vueå“åº”å¼æ›´æ–°
                    nextTick(() => {
                        console.log(`ğŸ¨ [${timestamp}] Vueå“åº”å¼æ›´æ–°å®Œæˆï¼Œå½“å‰ç¿»è¯‘çŠ¶æ€: ${translationEnabled.value}`);
                    });
                }

                // ==================== äº‹ä»¶å¤„ç† ====================

                function handleKeydown(event) {
                    switch (event.key) {
                        case 'ArrowLeft':
                            event.preventDefault();
                            previousPage();
                            break;
                        case 'ArrowRight':
                            event.preventDefault();
                            nextPage();
                            break;
                        case 'Escape':
                            if (isFullscreen.value) {
                                exitFullscreen();
                            }
                            break;
                        case 'F11':
                            event.preventDefault();
                            toggleFullscreen();
                            break;
                    }
                }

                function onImageClick(event) {
                    // ç‚¹å‡»å›¾ç‰‡å·¦åŠéƒ¨åˆ†ä¸Šä¸€é¡µï¼Œå³åŠéƒ¨åˆ†ä¸‹ä¸€é¡µ
                    const rect = event.currentTarget.getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const centerX = rect.width / 2;

                    if (clickX < centerX) {
                        previousPage();
                    } else {
                        nextPage();
                    }
                }

                function onImageLoad() {
                    console.log('å›¾ç‰‡åŠ è½½å®Œæˆ');
                }

                function onImageError() {
                    console.error('å›¾ç‰‡åŠ è½½å¤±è´¥');
                    ElMessage.error('å›¾ç‰‡åŠ è½½å¤±è´¥');
                }

                // ==================== å…¨å±æ§åˆ¶ ====================

                function toggleFullscreen() {
                    if (isFullscreen.value) {
                        exitFullscreen();
                    } else {
                        enterFullscreen();
                    }
                }

                function enterFullscreen() {
                    const element = viewerContent.value;
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                }

                function exitFullscreen() {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }

                function handleFullscreenChange() {
                    isFullscreen.value = !!document.fullscreenElement;
                }

                // ==================== å¯¼èˆª ====================
                // iframeæ–¹æ¡ˆä¸éœ€è¦è¿”å›æŒ‰é’®ï¼Œç”±çˆ¶é¡µé¢æ§åˆ¶å…³é—­

                return {
                    // æ•°æ®
                    mangaInfo,
                    currentPage,
                    showPageInput,
                    pageInputText,
                    currentImageUrls,
                    isLoading,
                    isFullscreen,
                    displayMode,
                    actualDisplayMode,
                    translationEnabled,
                    progressPercentage,
                    progressCircumference,
                    progressOffset,
                    screenInfo,
                    thumbStyle,
                    isDragging,



                    // DOMå¼•ç”¨
                    viewerContent,
                    mangaImage,
                    pageInputRef,
                    sliderContainer,

                    // æ–¹æ³•
                    loadCurrentPage,
                    previousPage,
                    nextPage,
                    onPageChange,
                    onPageInputEnter,
                    onPageInputBlur,
                    cancelPageInput,
                    applyPageInput,
                    toggleDisplayMode,
                    toggleTranslation,
                    onImageClick,
                    onImageLoad,
                    onImageError,
                    toggleFullscreen,
                    onThumbMouseDown,
                    onTrackClick,


                };
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>

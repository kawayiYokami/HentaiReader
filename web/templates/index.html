<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>漫画翻译工具 - Web UI</title>

    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">

    <!-- 自定义主题 -->
    <link rel="stylesheet" href="/static/css/modern-theme.css">

    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- Element Plus JS -->
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>

    <!-- Element Plus Icons -->
    <script src="https://unpkg.com/@element-plus/icons-vue/dist/index.iife.js"></script>

    <!-- Axios -->
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

    <!-- 前端文件处理库 -->
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <!-- 主题管理器 -->
    <script src="/static/js/theme-manager.js"></script>
</head>
<body>
    <div id="app">
        <div class="app-container">
            <!-- 主要内容区域 -->
            <div class="main-content">
                <!-- 侧边栏 -->
                <div class="sidebar" :class="{ 'collapsed': sidebarCollapsed }">
                    <!-- 汉堡包按钮 -->
                    <div class="hamburger-btn" @click="toggleSidebar">
                        <div class="hamburger-line"></div>
                        <div class="hamburger-line"></div>
                        <div class="hamburger-line"></div>
                    </div>

                    <!-- 导航菜单 -->
                    <nav class="nav-menu">
                        <div class="nav-item" :class="{ active: activeMenu === 'home' }" @click="handleMenuSelect('home')">
                            <div class="nav-icon">🏠</div>
                            <span class="nav-text">首页</span>
                        </div>

                        <div class="nav-item" :class="{ active: activeMenu === 'manga-browser' }" @click="handleMenuSelect('manga-browser')">
                            <div class="nav-icon">📚</div>
                            <span class="nav-text">漫画浏览</span>
                        </div>

                        <div class="nav-item" :class="{ active: activeMenu === 'translation' }" @click="handleMenuSelect('translation')">
                            <div class="nav-icon">🔤</div>
                            <span class="nav-text">漫画翻译</span>
                        </div>

                        <div class="nav-item" :class="{ active: activeMenu === 'compression' }" @click="handleMenuSelect('compression')">
                            <div class="nav-icon">🗜️</div>
                            <span class="nav-text">漫画压缩</span>
                        </div>

                        <div v-if="isLocalAccess" class="nav-item" :class="{ active: activeMenu === 'cache' }" @click="handleMenuSelect('cache')">
                            <div class="nav-icon">💾</div>
                            <span class="nav-text">缓存管理</span>
                        </div>
                    </nav>

                    <!-- 底部设置 -->
                    <div class="nav-footer">
                        <div class="nav-item" :class="{ active: activeMenu === 'settings' }" @click="handleMenuSelect('settings')">
                            <div class="nav-icon">⚙️</div>
                            <span class="nav-text">设置</span>
                        </div>
                    </div>
                </div>

                <!-- 内容区域 -->
                <div class="content-area">
                    <!-- 首页内容 -->
                    <div v-if="activeMenu === 'home'">
                        <!-- 远程访问安全提示 -->
                        <el-alert v-if="!isLocalAccess" type="warning" :closable="false" style="margin-bottom: 16px;">
                            <template #title>🔒 远程访问安全模式</template>
                            <ul style="margin: 8px 0; padding-left: 20px;">
                                <li>仅支持漫画阅读功能</li>
                                <li>无法添加新漫画到库中</li>
                                <li>翻译/压缩仅支持文件选择处理</li>
                                <li>不支持直接替换原文件</li>
                            </ul>
                        </el-alert>

                        <div class="welcome-card">
                            <h2>🎌 欢迎使用漫画翻译工具</h2>
                            <p v-if="isLocalAccess">这是Web版本的用户界面，提供与桌面版相同的强大功能</p>
                            <p v-else>远程访问模式 - 提供安全的漫画阅读和处理功能</p>
                            <el-button type="primary" @click="handleMenuSelect('manga-browser')">
                                开始使用
                            </el-button>
                        </div>

                        <div class="feature-grid">
                            <div class="feature-card">
                                <div class="feature-icon">📚</div>
                                <h3>漫画浏览</h3>
                                <p>浏览和管理你的漫画收藏，支持多种格式和标签过滤</p>
                            </div>

                            <div class="feature-card">
                                <div class="feature-icon">🔤</div>
                                <h3>OCR识别</h3>
                                <p>精准识别漫画中的文字，支持多种语言</p>
                            </div>

                            <div class="feature-card">
                                <div class="feature-icon">🌐</div>
                                <h3>多引擎翻译</h3>
                                <p>支持Google翻译、智谱AI等多种翻译引擎</p>
                            </div>

                            <div class="feature-card">
                                <div class="feature-icon">🗜️</div>
                                <h3>WebP压缩</h3>
                                <p>将漫画转换为WebP格式，大幅减小文件大小</p>
                            </div>

                            <div class="feature-card">
                                <div class="feature-icon">⚡</div>
                                <h3>批量处理</h3>
                                <p>一键翻译整个章节，提高工作效率</p>
                            </div>
                        </div>
                    </div>

                    <!-- 设置页面 -->
                    <div v-else-if="activeMenu === 'settings'">
                        <div class="welcome-card">
                            <h2>⚙️ 应用设置</h2>
                            <p>配置应用的外观和行为</p>
                        </div>

                        <!-- 主题设置 -->
                        <el-card style="margin-top: 24px;">
                            <template #header>
                                <span>🎨 主题设置</span>
                            </template>

                            <div>
                                <h4>外观主题</h4>
                                <p style="color: var(--text-secondary); margin-bottom: 16px;">
                                    选择应用的外观主题，支持浅色模式、深色模式或跟随系统设置
                                </p>

                                <el-radio-group v-model="currentTheme" @change="onThemeChange">
                                    <el-radio value="light" style="display: block; margin-bottom: 12px;">
                                        ☀️ 浅色模式 - 明亮的白色背景，适合白天使用
                                    </el-radio>

                                    <el-radio value="dark" style="display: block; margin-bottom: 12px;">
                                        🌙 深色模式 - 深色背景，减少眼部疲劳
                                    </el-radio>

                                    <el-radio value="auto" style="display: block;">
                                        🔄 跟随系统 - 根据系统设置自动切换主题
                                    </el-radio>
                                </el-radio-group>

                                <div style="margin-top: 16px; padding: 16px; background: var(--bg-tertiary); border-radius: 6px;">
                                    <strong><span v-text="themeIcon"></span> 当前主题: <span v-text="themeDisplayName"></span></strong>
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                        主题设置会自动保存到本地存储
                                    </div>
                                </div>
                            </div>
                        </el-card>
                    </div>

                    <!-- 漫画浏览页面 -->
                    <div v-else-if="activeMenu === 'manga-browser'">
                        <div class="manga-browser">
                            <!-- 搜索和过滤 -->
                            <el-card>
                                <div class="manga-filters">
                                    <!-- 顶部操作栏 -->
                                    <div class="filter-header">
                                        <!-- 搜索框 -->
                                        <el-input
                                            v-model="searchQuery"
                                            placeholder="搜索漫画标题..."
                                            prefix-icon="Search"
                                            clearable
                                            style="flex: 1; margin-right: 16px;">
                                        </el-input>

                                        <!-- 添加漫画按钮 - 仅本地访问 -->
                                        <el-dropdown v-if="isLocalAccess" @command="handleAddManga" :loading="isLoading">
                                            <el-button type="primary" :loading="isLoading">
                                                ➕ 添加漫画
                                                <el-icon class="el-icon--right"><arrow-down /></el-icon>
                                            </el-button>
                                            <template #dropdown>
                                                <el-dropdown-menu>
                                                    <el-dropdown-item command="files">📄 选择文件 (ZIP)</el-dropdown-item>
                                                    <el-dropdown-item command="directory">📁 选择目录 (扫描)</el-dropdown-item>
                                                </el-dropdown-menu>
                                            </template>
                                        </el-dropdown>

                                        <!-- 远程访问提示 -->
                                        <el-tooltip v-else content="远程访问不支持添加漫画功能" placement="bottom">
                                            <el-button type="primary" disabled>
                                                🔒 添加漫画 (仅本地)
                                            </el-button>
                                        </el-tooltip>

                                        <!-- 清除过滤按钮 -->
                                        <el-button
                                            v-if="selectedTags.length > 0"
                                            size="default"
                                            type="info"
                                            text
                                            @click="clearTagFilters"
                                            style="margin-left: 8px;">
                                            清除 (<span v-text="selectedTags.length"></span>)
                                        </el-button>
                                    </div>

                                    <!-- 标签分类过滤 -->
                                    <div v-if="Object.keys(tagsByCategory).length > 0" class="tag-category-filters">
                                        <!-- 标签分类选择器 -->
                                        <el-tabs v-model="activeTagCategory" type="card" class="tag-category-tabs">
                                            <el-tab-pane
                                                v-for="(tags, category) in tagsByCategory"
                                                :key="category"
                                                :label="`${category} (${tags.length})`"
                                                :name="category">

                                                <div class="tag-list">
                                                    <el-tag
                                                        v-for="tag in tags.slice(0, showAllTags[category] ? tags.length : 20)"
                                                        :key="tag.full"
                                                        :type="selectedTags.includes(tag.full) ? 'primary' : ''"
                                                        :effect="selectedTags.includes(tag.full) ? 'dark' : 'plain'"
                                                        @click="toggleTag(tag.full)"
                                                        class="filter-tag">
                                                        <span v-text="tag.display"></span>
                                                    </el-tag>

                                                    <!-- 显示更多按钮 -->
                                                    <el-button
                                                        v-if="tags.length > 20"
                                                        size="small"
                                                        type="info"
                                                        text
                                                        @click="toggleShowAllTags(category)"
                                                        class="show-more-btn">
                                                        <span v-text="showAllTags[category] ? '收起' : `显示全部 ${tags.length} 个`"></span>
                                                    </el-button>
                                                </div>
                                            </el-tab-pane>
                                        </el-tabs>
                                    </div>
                                </div>
                            </el-card>

                            <!-- 空状态 -->
                            <el-empty v-if="mangaList.length === 0 && !isLoading"
                                      description="缓存中暂无漫画"
                                      style="margin-top: 40px;">
                            </el-empty>

                            <!-- 加载状态 -->
                            <div v-if="isLoading" style="text-align: center; margin-top: 40px;">
                                <el-loading-spinner size="large"></el-loading-spinner>
                                <p style="margin-top: 16px; color: var(--text-secondary);">正在加载漫画列表...</p>
                            </div>

                            <!-- 漫画列表 -->
                            <div v-else-if="filteredMangaList.length > 0" class="manga-grid">
                                <div v-for="manga in filteredMangaList"
                                     :key="manga.file_path"
                                     :data-manga-path="manga.file_path"
                                     class="manga-card"
                                     @click="selectManga(manga)"
                                     :ref="el => { if (el) observeCard(el) }">

                                    <!-- 封面图片 -->
                                    <div class="manga-cover">
                                        <!-- 缩略图（从缓存加载） -->
                                        <img v-if="getThumbnailUrl(manga.file_path)"
                                             :src="getThumbnailUrl(manga.file_path)"
                                             :alt="getTitleTag(manga.tags) || '漫画封面'"
                                             class="cover-image">

                                        <!-- 加载中状态 -->
                                        <div v-else-if="isThumbnailLoading(manga.file_path)" class="cover-loading">
                                            <div class="loading-spinner">⏳</div>
                                            <div class="loading-text">加载中...</div>
                                        </div>

                                        <!-- 无图片占位符 -->
                                        <div v-else class="cover-placeholder">
                                            <div class="placeholder-icon">
                                                <span v-if="manga.file_type === 'folder'">📁</span>
                                                <span v-else-if="manga.file_type === 'zip'">📦</span>
                                                <span v-else>📄</span>
                                            </div>
                                        </div>

                                        <!-- 页数角标 -->
                                        <div class="page-count" v-text="manga.total_pages"></div>
                                    </div>

                                    <!-- 标题标签（默认显示） -->
                                    <div class="manga-title clickable-title"
                                         v-if="getTitleTag(manga.tags)"
                                         @click.stop="onTitleClick(getTitleTag(manga.tags))"
                                         :title="`点击搜索: ${getTitleTag(manga.tags)}`">
                                        <span v-text="getTitleTag(manga.tags)"></span>
                                    </div>

                                    <!-- 其他标签（悬停显示） -->
                                    <div class="manga-tags" v-if="getOtherTags(manga.tags).length > 0">
                                        <div class="tag clickable-tag"
                                             v-for="tag in getOtherTags(manga.tags).slice(0, 3)"
                                             :key="tag"
                                             @click.stop="onTagClick(tag)"
                                             :title="`点击搜索: ${tag}`">
                                            <span v-text="tag"></span>
                                        </div>
                                        <div class="tag more-tag clickable-tag"
                                             v-if="getOtherTags(manga.tags).length > 3"
                                             @click.stop="showAllTags(manga)"
                                             title="点击查看所有标签">
                                            +<span v-text="getOtherTags(manga.tags).length - 3"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 无结果状态 -->
                            <el-empty v-else-if="mangaList.length > 0 && filteredMangaList.length === 0 && !isLoading"
                                      description="未找到匹配的漫画"
                                      style="margin-top: 40px;">
                                <el-button @click="clearFilters">清除过滤条件</el-button>
                            </el-empty>
                        </div>
                    </div>

                    <!-- 缓存管理页面 - 极简设计 -->
                    <div v-else-if="activeMenu === 'cache'">
                        <div class="cache-management-minimal">
                            <!-- 缓存概览 -->
                            <div class="cache-overview">
                                <h2>缓存概览</h2>
                                <div class="cache-list">
                                    <div
                                        v-for="cacheType in cacheTypes"
                                        :key="cacheType.key"
                                        class="cache-item"
                                        :class="{ 'active': selectedCacheType === cacheType.key }"
                                        @click="selectCacheType(cacheType.key)">

                                        <div class="cache-basic-info">
                                            <span class="cache-icon" v-text="cacheType.icon"></span>
                                            <span class="cache-name" v-text="cacheType.name"></span>
                                        </div>

                                        <div class="cache-stats">
                                            <span class="stat-text" v-text="getCacheTypeStats(cacheType.key).entries + ' 条'"></span>
                                            <span class="stat-divider">|</span>
                                            <span class="stat-text" v-text="getCacheTypeStats(cacheType.key).size"></span>
                                        </div>

                                        <div class="cache-actions" v-if="selectedCacheType === cacheType.key">
                                            <el-button
                                                size="small"
                                                type="danger"
                                                text
                                                @click.stop="clearSingleCache(cacheType.key)"
                                                :loading="loadingStates[cacheType.key]?.clearing">
                                                清空
                                            </el-button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 缓存详情 -->
                            <div v-if="selectedCacheType" class="cache-detail">
                                <div class="detail-header">
                                    <h3 v-text="getSelectedCacheName()"></h3>
                                    <div class="detail-actions">
                                        <el-button
                                            size="small"
                                            type="primary"
                                            @click="showAddHarmonizationDialog"
                                            v-if="selectedCacheType === 'harmonization_map'">
                                            添加映射
                                        </el-button>
                                    </div>
                                </div>

                                <!-- 搜索 -->
                                <div class="search-bar">
                                    <el-input
                                        v-model="cacheSearchQuery"
                                        placeholder="搜索..."
                                        prefix-icon="Search"
                                        clearable
                                        @input="filterCacheEntries">
                                    </el-input>
                                </div>

                                <!-- 条目列表 -->
                                <div class="entries-container">
                                    <el-table
                                        :data="filteredCacheEntries"
                                        v-loading="isLoadingEntries"
                                        style="width: 100%">

                                        <el-table-column prop="key" label="键" min-width="200" show-overflow-tooltip>
                                            <template #default="scope">
                                                <span class="cache-key" v-text="scope.row.key"></span>
                                            </template>
                                        </el-table-column>

                                        <el-table-column prop="value_preview" label="内容" min-width="300" show-overflow-tooltip>
                                            <template #default="scope">
                                                <div class="content-with-tags">
                                                    <span class="cache-content" v-text="scope.row.value_preview"></span>
                                                    <el-tag
                                                        v-if="selectedCacheType === 'translation' && scope.row.is_sensitive"
                                                        type="warning"
                                                        size="small"
                                                        class="sensitive-tag">
                                                        敏感
                                                    </el-tag>
                                                </div>
                                            </template>
                                        </el-table-column>

                                        <el-table-column label="操作" width="80" align="center">
                                            <template #default="scope">
                                                <el-button
                                                    size="small"
                                                    text
                                                    @click="editCacheEntry(scope.row)">
                                                    编辑
                                                </el-button>
                                            </template>
                                        </el-table-column>
                                    </el-table>

                                    <!-- 简化分页 -->
                                    <div class="pagination" v-if="totalEntries > pageSize">
                                        <el-pagination
                                            :current-page="currentPage"
                                            :page-size="pageSize"
                                            :total="totalEntries"
                                            layout="prev, pager, next"
                                            @current-change="onPageChange">
                                        </el-pagination>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 漫画翻译页面 -->
                    <div v-else-if="activeMenu === 'translation'">
                        <div class="translation-interface">
                            <!-- 页面标题 -->
                            <div class="welcome-card">
                                <h2>🌐 前端漫画翻译器</h2>
                                <p>完全在浏览器中运行的AI驱动漫画翻译工具，保护您的隐私</p>
                            </div>

                            <div class="translation-layout">
                                <!-- 左侧控制面板 -->
                                <div class="translation-control">
                                    <el-card>
                                        <template #header>
                                            <span>📁 文件选择</span>
                                        </template>

                                        <!-- 文件选择区域 -->
                                        <div class="file-selection">
                                            <div class="upload-area"
                                                 @click="triggerFileSelect"
                                                 @dragover.prevent="handleDragOver"
                                                 @dragleave.prevent="handleDragLeave"
                                                 @drop.prevent="handleDrop"
                                                 :class="{ dragover: isDragOver }"
                                                 style="border: 2px dashed #dcdfe6; border-radius: 8px; padding: 30px; text-align: center; transition: all 0.3s; cursor: pointer;">

                                                <el-icon size="48" color="#c0c4cc">
                                                    <upload-filled />
                                                </el-icon>

                                                <h3 style="margin: 16px 0 8px 0; color: #303133;">拖拽文件到此处，或点击选择文件</h3>
                                                <p style="margin: 0; color: #909399; font-size: 14px;">支持 ZIP、CBZ、CBR 格式的漫画文件</p>

                                                <input ref="fileInput"
                                                       type="file"
                                                       multiple
                                                       accept=".zip,.cbz,.cbr"
                                                       @change="handleFileSelect"
                                                       style="display: none;">
                                            </div>


                                        </div>
                                    </el-card>

                                    <el-card style="margin-top: 16px;">
                                        <template #header>
                                            <span>⚙️ 翻译设置</span>
                                        </template>

                                        <!-- 翻译参数设置 -->
                                        <div class="translation-params">
                                            <el-form label-width="80px" size="default">
                                                <el-form-item label="源语言">
                                                    <el-select v-model="translationSettings.sourceLang" style="width: 100%">
                                                        <el-option label="自动检测" value="auto"></el-option>
                                                        <el-option label="日语" value="ja"></el-option>
                                                        <el-option label="英语" value="en"></el-option>
                                                        <el-option label="韩语" value="ko"></el-option>
                                                    </el-select>
                                                </el-form-item>

                                                <el-form-item label="目标语言">
                                                    <el-select v-model="translationSettings.targetLang" style="width: 100%">
                                                        <el-option label="简体中文" value="zh-CN"></el-option>
                                                        <el-option label="繁体中文" value="zh-TW"></el-option>
                                                        <el-option label="英语" value="en"></el-option>
                                                        <el-option label="日语" value="ja"></el-option>
                                                    </el-select>
                                                </el-form-item>

                                                <el-form-item label="翻译引擎">
                                                    <el-select v-model="translationSettings.engine" style="width: 100%">
                                                        <el-option label="智谱AI" value="智谱"></el-option>
                                                        <el-option label="Google翻译" value="Google"></el-option>
                                                    </el-select>
                                                </el-form-item>

                                                <el-form-item label="输出质量">
                                                    <el-slider
                                                        v-model="translationSettings.webpQuality"
                                                        :min="50"
                                                        :max="100"
                                                        :step="5"
                                                        show-input
                                                        style="width: 100%;">
                                                    </el-slider>
                                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                                        输出图片的WebP质量 (50-100)
                                                    </div>
                                                </el-form-item>
                                            </el-form>
                                        </div>
                                    </el-card>

                                    <el-card style="margin-top: 16px;">
                                        <template #header>
                                            <div style="text-align: center;">🎯 操作</div>
                                        </template>

                                        <!-- 操作按钮 -->
                                        <div style="padding: 0;">
                                            <div style="margin-bottom: 8px;">
                                                <el-button
                                                    type="primary"
                                                    @click="startTranslation"
                                                    :disabled="translationTasks.length === 0 || isProcessing"
                                                    :loading="isProcessing"
                                                    style="width: 100%; height: 40px; display: block; margin: 0 auto;">
                                                    <span v-if="isProcessing">🔄 翻译中...</span>
                                                    <span v-else>🌐 开始翻译</span>
                                                </el-button>
                                            </div>

                                            <div style="margin-bottom: 8px;">
                                                <el-button
                                                    type="warning"
                                                    @click="stopTranslation"
                                                    :disabled="!isProcessing"
                                                    style="width: 100%; height: 40px; display: block; margin: 0 auto;">
                                                    ⏹️ 停止翻译
                                                </el-button>
                                            </div>

                                            <div style="margin-bottom: 0;">
                                                <el-button
                                                    @click="clearTranslationTasks"
                                                    :disabled="translationTasks.length === 0"
                                                    style="width: 100%; height: 40px; display: block; margin: 0 auto;">
                                                    🗑️ 清空任务列表
                                                </el-button>
                                            </div>
                                        </div>

                                        <!-- 提示信息 -->
                                        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 4px; padding: 12px; margin-top: 16px;">
                                            <div style="color: #0369a1; font-size: 12px; font-weight: bold; text-align: center;">💡 翻译说明</div>
                                            <ul style="color: #666; font-size: 11px; margin: 8px 0 0 16px; padding: 0;">
                                                <li>文件处理完全在浏览器中进行</li>
                                                <li>翻译完成后自动下载结果文件</li>
                                                <li>支持OCR识别和AI翻译</li>
                                                <li>输出为WebP格式压缩包</li>
                                            </ul>
                                        </div>
                                    </el-card>


                                </div>

                                <!-- 右侧任务列表 -->
                                <div class="translation-tasks">
                                    <el-card>
                                        <template #header>
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span>📋 翻译任务</span>
                                                <span class="task-count"><span v-text="translationTasks.length"></span> 个任务</span>
                                            </div>
                                        </template>

                                        <!-- 空状态 -->
                                        <el-empty
                                            v-if="translationTasks.length === 0"
                                            description="暂无翻译任务"
                                            :image-size="120">
                                            <el-button type="primary" @click="triggerFileSelect">
                                                选择文件开始翻译
                                            </el-button>
                                        </el-empty>

                                        <!-- 任务列表 -->
                                        <div v-else class="task-list">
                                            <div
                                                v-for="(task, index) in translationTasks"
                                                :key="task.id"
                                                class="task-item"
                                                :class="{
                                                    'task-processing': task.status === 'processing',
                                                    'task-completed': task.status === 'completed',
                                                    'task-error': task.status === 'error'
                                                }">

                                                <div class="task-info">
                                                    <div class="task-name" :title="task.fileName">
                                                        <span v-text="task.fileName"></span>
                                                    </div>
                                                    <div class="task-details">
                                                        <span class="task-pages"><span v-text="task.totalPages"></span> 页</span>
                                                        <span class="task-status" v-text="getTaskStatusText(task.status)"></span>
                                                    </div>
                                                </div>

                                                <div class="task-progress" v-if="task.status === 'processing'">
                                                    <el-progress
                                                        :percentage="task.progress"
                                                        :show-text="false"
                                                        :stroke-width="4">
                                                    </el-progress>
                                                    <span class="progress-detail"><span v-text="task.currentPage"></span> / <span v-text="task.totalPages"></span></span>
                                                </div>

                                                <div class="task-actions">
                                                    <div class="task-status">
                                                        <el-tag
                                                            v-if="task.status === 'completed'"
                                                            type="success"
                                                            size="small">
                                                            ✅ 完成
                                                        </el-tag>
                                                        <el-tag
                                                            v-else-if="task.status === 'error'"
                                                            type="danger"
                                                            size="small">
                                                            ❌ 失败
                                                        </el-tag>
                                                        <el-tag
                                                            v-else-if="task.status === 'processing'"
                                                            type="warning"
                                                            size="small">
                                                            ⏳ 处理中
                                                        </el-tag>
                                                        <el-tag
                                                            v-else
                                                            type="info"
                                                            size="small">
                                                            ⏸️ 等待
                                                        </el-tag>
                                                    </div>

                                                    <div class="task-buttons">
                                                        <el-button
                                                            v-if="task.status === 'completed'"
                                                            size="small"
                                                            type="primary"
                                                            @click="downloadTask(task)">
                                                            📥 下载
                                                        </el-button>
                                                        <el-button
                                                            size="small"
                                                            type="danger"
                                                            @click="removeTask(index)">
                                                            🗑️ 移除
                                                        </el-button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </el-card>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 漫画压缩页面 -->
                    <div v-else-if="activeMenu === 'compression'">
                        <div class="compression-interface">
                            <!-- 页面标题 -->
                            <div class="welcome-card">
                                <h2>🗜️ 前端漫画压缩器</h2>
                                <p>完全在浏览器中运行的WebP压缩工具，大幅减小文件大小</p>
                            </div>

                            <div class="compression-layout" style="display: grid; grid-template-columns: 400px 1fr; gap: 20px; align-items: start;">
                                <!-- 左侧控制面板 -->
                                <div class="compression-control">
                                    <el-card>
                                        <template #header>
                                            <span>📁 文件选择</span>
                                        </template>

                                        <!-- 文件选择区域 -->
                                        <div class="file-selection">
                                            <div class="upload-area"
                                                 @click="triggerCompressionFileSelect"
                                                 @dragover.prevent="handleCompressionDragOver"
                                                 @dragleave.prevent="handleCompressionDragLeave"
                                                 @drop.prevent="handleCompressionDrop"
                                                 :class="{ dragover: isCompressionDragOver }"
                                                 style="border: 2px dashed #dcdfe6; border-radius: 8px; padding: 30px; text-align: center; transition: all 0.3s; cursor: pointer;">

                                                <el-icon size="48" color="#c0c4cc">
                                                    <upload-filled />
                                                </el-icon>

                                                <h3 style="margin: 16px 0 8px 0; color: #303133;">拖拽文件到此处，或点击选择文件</h3>
                                                <p style="margin: 0; color: #909399; font-size: 14px;">支持 ZIP、CBZ、CBR 格式的漫画文件</p>

                                                <input ref="compressionFileInput"
                                                       type="file"
                                                       multiple
                                                       accept=".zip,.cbz,.cbr"
                                                       @change="handleCompressionFileSelect"
                                                       style="display: none;">
                                            </div>


                                        </div>
                                    </el-card>

                                    <el-card style="margin-top: 16px;">
                                        <template #header>
                                            <span>⚙️ 压缩设置</span>
                                        </template>

                                        <!-- 压缩参数设置 -->
                                        <div class="compression-params">
                                            <el-form label-width="80px" size="default">
                                                <el-form-item label="压缩模式">
                                                    <el-radio-group v-model="compressionSettings.lossless" style="width: 100%;">
                                                        <el-radio :value="false" style="width: 100%; margin-bottom: 8px;">
                                                            🎯 有损压缩 (推荐)
                                                        </el-radio>
                                                        <el-radio :value="true" style="width: 100%;">
                                                            💎 无损压缩
                                                        </el-radio>
                                                    </el-radio-group>
                                                </el-form-item>

                                                <el-form-item label="压缩质量" v-if="!compressionSettings.lossless">
                                                    <el-slider
                                                        v-model="compressionSettings.quality"
                                                        :min="10"
                                                        :max="100"
                                                        :step="5"
                                                        show-input
                                                        style="width: 100%;">
                                                    </el-slider>
                                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                                        10=最小文件，75=推荐值，100=最高质量
                                                    </div>
                                                </el-form-item>
                                            </el-form>
                                        </div>
                                    </el-card>

                                    <el-card style="margin-top: 16px;">
                                        <template #header>
                                            <div style="text-align: center;">🎯 操作</div>
                                        </template>

                                        <!-- 操作按钮 -->
                                        <div style="padding: 0;">
                                            <div style="margin-bottom: 8px;">
                                                <el-button
                                                    type="primary"
                                                    @click="startCompression"
                                                    :disabled="compressionTasks.length === 0 || isCompressing"
                                                    :loading="isCompressing"
                                                    style="width: 100%; height: 40px; display: block; margin: 0 auto;">
                                                    <span v-if="isCompressing">🔄 压缩中...</span>
                                                    <span v-else>🗜️ 开始压缩</span>
                                                </el-button>
                                            </div>

                                            <div style="margin-bottom: 8px;">
                                                <el-button
                                                    type="warning"
                                                    @click="stopCompression"
                                                    :disabled="!isCompressing"
                                                    style="width: 100%; height: 40px; display: block; margin: 0 auto;">
                                                    ⏹️ 停止压缩
                                                </el-button>
                                            </div>

                                            <div style="margin-bottom: 0;">
                                                <el-button
                                                    @click="clearCompressionTasks"
                                                    :disabled="compressionTasks.length === 0"
                                                    style="width: 100%; height: 40px; display: block; margin: 0 auto;">
                                                    🗑️ 清空任务列表
                                                </el-button>
                                            </div>
                                        </div>

                                        <!-- 提示信息 -->
                                        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 4px; padding: 12px; margin-top: 16px;">
                                            <div style="color: #0369a1; font-size: 12px; font-weight: bold; text-align: center;">💡 压缩说明</div>
                                            <ul style="color: #666; font-size: 11px; margin: 8px 0 0 16px; padding: 0;">
                                                <li>文件处理完全在浏览器中进行</li>
                                                <li>压缩完成后自动下载结果文件</li>
                                                <li>支持25%压缩率预检测</li>
                                                <li>输出为WebP格式压缩包</li>
                                            </ul>
                                        </div>
                                    </el-card>
                                </div>

                                <!-- 右侧任务列表 -->
                                <div class="compression-tasks">
                                    <el-card>
                                        <template #header>
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span>📋 压缩任务</span>
                                                <span class="task-count"><span v-text="compressionTasks.length"></span> 个任务</span>
                                            </div>
                                        </template>

                                        <!-- 空状态 -->
                                        <el-empty
                                            v-if="compressionTasks.length === 0"
                                            description="暂无压缩任务"
                                            :image-size="120">
                                            <el-button type="primary" @click="triggerCompressionFileSelect">
                                                选择文件开始压缩
                                            </el-button>
                                        </el-empty>

                                        <!-- 任务列表 -->
                                        <div v-else class="task-list" style="max-height: 600px; overflow-y: auto;">
                                            <div
                                                v-for="(task, index) in compressionTasks"
                                                :key="task.id"
                                                class="task-item"
                                                :class="{
                                                    'task-processing': task.status === 'processing',
                                                    'task-completed': task.status === 'completed',
                                                    'task-error': task.status === 'error'
                                                }"
                                                style="padding: 16px; border: 1px solid #ebeef5; border-radius: 8px; margin-bottom: 12px;">

                                                <div class="task-info">
                                                    <div class="task-name" style="font-weight: 500; margin-bottom: 8px;" :title="task.fileName">
                                                        <span v-text="task.fileName"></span>
                                                    </div>
                                                    <div class="task-details" style="font-size: 12px; color: #909399;">
                                                        <span class="task-status" v-text="getCompressionTaskStatusText(task.status)"></span>
                                                    </div>
                                                </div>

                                                <div class="task-progress" v-if="task.status === 'processing'" style="margin: 12px 0;">
                                                    <el-progress
                                                        :percentage="task.progress"
                                                        :show-text="false"
                                                        :stroke-width="6">
                                                    </el-progress>
                                                    <div style="margin-top: 4px; font-size: 12px; color: #666;">
                                                        <span v-text="task.currentStep"></span>
                                                        <span style="float: right;" v-text="task.progress + '%'"></span>
                                                    </div>
                                                </div>

                                                <div class="task-actions" style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px;">
                                                    <div class="task-status">
                                                        <el-tag
                                                            v-if="task.status === 'completed'"
                                                            type="success"
                                                            size="small">
                                                            ✅ 完成
                                                        </el-tag>
                                                        <el-tag
                                                            v-else-if="task.status === 'error'"
                                                            type="danger"
                                                            size="small">
                                                            ❌ 失败
                                                        </el-tag>
                                                        <el-tag
                                                            v-else-if="task.status === 'processing'"
                                                            type="warning"
                                                            size="small">
                                                            ⏳ 处理中
                                                        </el-tag>
                                                        <el-tag
                                                            v-else
                                                            type="info"
                                                            size="small">
                                                            ⏸️ 等待
                                                        </el-tag>
                                                    </div>

                                                    <div class="task-buttons">
                                                        <el-button
                                                            v-if="task.status === 'completed'"
                                                            size="small"
                                                            type="primary"
                                                            @click="downloadCompressionTask(task)">
                                                            📥 下载
                                                        </el-button>
                                                        <el-button
                                                            size="small"
                                                            type="danger"
                                                            @click="removeCompressionTask(index)">
                                                            🗑️ 移除
                                                        </el-button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </el-card>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 其他页面内容 -->
                    <div v-else>
                        <el-card>
                            <h2 v-text="getPageTitle()"></h2>
                            <p><span v-text="activeMenu"></span> 功能正在开发中...</p>
                            <el-button @click="checkHealth">测试API连接</el-button>
                        </el-card>
                    </div>
                </div>
            </div>
        </div>

        <!-- 隐藏的文件选择器 -->
        <!-- ZIP文件选择器 -->
        <input
            ref="fileInput"
            type="file"
            multiple
            accept=".zip,.cbz,.cbr"
            style="display: none;"
            @change="onFilesSelected">

        <!-- 目录选择器 -->
        <input
            ref="directoryInput"
            type="file"
            webkitdirectory
            style="display: none;"
            @change="onDirectorySelected">

        <!-- 统一编辑对话框 -->
        <el-dialog
            v-model="editDialog.visible"
            :title="editDialog.title"
            width="600px"
            :close-on-click-modal="false">

            <div v-if="editDialog.type === 'harmonization_map'">
                <el-form label-width="100px">
                    <el-form-item label="原文">
                        <el-input
                            v-model="editDialog.originalText"
                            type="textarea"
                            :rows="3"
                            placeholder="请输入需要和谐化的原文"
                            :disabled="editDialog.isEditing">
                        </el-input>
                    </el-form-item>

                    <el-form-item label="和谐后文本">
                        <el-input
                            v-model="editDialog.harmonizedText"
                            type="textarea"
                            :rows="3"
                            placeholder="请输入和谐后的文本（留空表示删除原文）">
                        </el-input>
                    </el-form-item>
                </el-form>
            </div>

            <div v-else-if="editDialog.type === 'translation'">
                <el-form label-width="100px">
                    <el-form-item label="缓存键">
                        <el-input v-model="editDialog.key" disabled></el-input>
                    </el-form-item>

                    <el-form-item label="翻译内容">
                        <el-input
                            v-model="editDialog.content"
                            type="textarea"
                            :rows="4"
                            placeholder="翻译内容">
                        </el-input>
                    </el-form-item>

                    <el-form-item label="敏感标记">
                        <el-switch v-model="editDialog.isSensitive"></el-switch>
                    </el-form-item>

                    <div v-if="editDialog.isSensitive" class="sensitive-actions">
                        <el-button
                            type="primary"
                            @click="generateHarmonizationFromCurrent"
                            size="small">
                            🛡️ 生成和谐映射
                        </el-button>
                    </div>
                </el-form>
            </div>

            <div v-else>
                <el-form label-width="100px">
                    <el-form-item label="缓存键">
                        <el-input v-model="editDialog.key" disabled></el-input>
                    </el-form-item>

                    <el-form-item label="内容">
                        <el-input
                            v-model="editDialog.content"
                            type="textarea"
                            :rows="4"
                            placeholder="缓存内容">
                        </el-input>
                    </el-form-item>
                </el-form>
            </div>

            <template #footer>
                <div class="dialog-footer-new">
                    <!-- 危险操作区域 -->
                    <div class="danger-zone" v-if="editDialog.isEditing">
                        <el-divider content-position="left">
                            <span class="danger-label">危险操作</span>
                        </el-divider>
                        <el-button
                            type="danger"
                            plain
                            @click="deleteCurrentEntry"
                            size="small"
                            class="delete-button">
                            🗑️ 删除此条目
                        </el-button>
                    </div>

                    <!-- 主要操作区域 -->
                    <div class="main-actions">
                        <el-button @click="cancelEdit" size="large">取消</el-button>
                        <el-button type="primary" @click="saveEdit" size="large">
                            <span v-if="editDialog.isEditing">保存修改</span>
                            <span v-else>添加</span>
                        </el-button>
                    </div>
                </div>
            </template>
        </el-dialog>
    </div>

    <script>
        const { createApp } = Vue;
        const { ElMessage } = ElementPlus;
        const { Delete, UploadFilled } = ElementPlusIconsVue;

        createApp({
            data() {
                return {
                    // 系统状态
                    isLocalAccess: ['localhost', '127.0.0.1', '::1'].includes(window.location.hostname),

                    activeMenu: 'home',
                    currentTheme: 'auto',
                    themeDisplayName: '跟随系统',
                    themeIcon: '🔄',
                    sidebarCollapsed: false,

                    // 漫画浏览相关数据
                    mangaList: [],
                    availableTags: [],
                    selectedTags: [],
                    searchQuery: '',
                    isLoading: false,

                    // 标签分类过滤
                    tagsByCategory: {},
                    activeTagCategory: '作者',
                    showAllTags: {},

                    // 新的缩略图系统
                    thumbnailCache: new Map(),
                    loadingThumbnails: new Set(),
                    thumbnailObserver: null,
                    visibleCards: new Set(),

                    // 缓存管理相关数据 - 全新设计
                    cacheTypes: [
                        { key: 'manga_list', name: '漫画列表', icon: '📚', description: '漫画文件扫描结果缓存' },
                        { key: 'ocr', name: 'OCR识别', icon: '🔤', description: '文字识别结果缓存' },
                        { key: 'translation', name: '翻译结果', icon: '🌐', description: '翻译结果缓存' },
                        { key: 'harmonization_map', name: '和谐映射', icon: '🛡️', description: '内容和谐化映射缓存' }
                    ],
                    selectedCacheType: null,
                    cacheStats: {},
                    cacheEntries: [],
                    filteredCacheEntries: [],
                    totalEntries: 0,
                    currentPage: 1,
                    pageSize: 20,
                    cacheSearchQuery: '',

                    // 简化的加载状态
                    loadingStates: {
                        manga_list: { clearing: false },
                        ocr: { clearing: false },
                        translation: { clearing: false },
                        harmonization_map: { clearing: false }
                    },
                    isLoadingEntries: false,

                    // 统一编辑对话框
                    editDialog: {
                        visible: false,
                        type: '', // 'harmonization_map', 'translation', 'ocr', 'manga_list'
                        title: '',
                        isEditing: false,
                        key: '',
                        content: '',
                        originalText: '',
                        harmonizedText: '',
                        isSensitive: false,
                        currentEntry: null
                    },

                    // 翻译功能数据
                    translationSettings: {
                        sourceLang: 'auto',
                        targetLang: 'zh-CN',
                        engine: '智谱',
                        webpQuality: 75  // Google推荐的默认质量
                    },
                    translationTasks: [],
                    isDragOver: false,
                    isProcessing: false,
                    translationStopped: false,  // 停止标志

                    // 压缩功能数据
                    compressionSettings: {
                        lossless: false,  // false=有损压缩, true=无损压缩
                        quality: 75  // 压缩质量
                    },
                    compressionTasks: [],
                    isCompressing: false,
                    isCompressionDragOver: false,
                    compressionStopped: false  // 停止标志
                };
            },
            computed: {
                filteredMangaList() {
                    let filtered = this.mangaList;

                    // 搜索过滤
                    if (this.searchQuery) {
                        const query = this.searchQuery.toLowerCase();
                        filtered = filtered.filter(manga =>
                            manga.title.toLowerCase().includes(query)
                        );
                    }

                    // 标签过滤
                    if (this.selectedTags.length > 0) {
                        filtered = filtered.filter(manga =>
                            this.selectedTags.some(tag => manga.tags.includes(tag))
                        );
                    }

                    return filtered;
                },

                // 检查是否有已完成的翻译任务
                hasCompletedTasks() {
                    return this.translationTasks.some(task => task.status === 'completed');
                }
            },
            mounted() {
                this.updateThemeState();
                window.addEventListener('themechange', () => {
                    this.updateThemeState();
                });

                // 初始化缩略图观察器
                this.initThumbnailObserver();

                // 初始化漫画数据
                this.loadInitialData();

                // 初始化缓存管理数据
                this.initCacheManagement();
            },

            beforeUnmount() {
                // 清理观察器
                if (this.thumbnailObserver) {
                    this.thumbnailObserver.disconnect();
                }
            },
            methods: {
                handleMenuSelect(key) {
                    this.activeMenu = key;
                },

                getPageTitle() {
                    const titles = {
                        'home': '首页',
                        'manga-browser': '漫画浏览',
                        'translation': '漫画翻译',
                        'compression': '漫画压缩',
                        'cache': '缓存管理',
                        'settings': '设置'
                    };
                    return titles[this.activeMenu] || '未知页面';
                },

                async checkHealth() {
                    try {
                        const response = await axios.get('/health');
                        ElMessage.success('API连接正常: ' + response.data.message);
                    } catch (error) {
                        ElMessage.error('API连接失败: ' + error.message);
                    }
                },

                toggleTheme() {
                    if (window.themeManager) {
                        window.themeManager.toggleTheme();
                        this.updateThemeState();
                        ElMessage.success(`已切换到: ${this.themeDisplayName}`);
                    }
                },

                updateThemeState() {
                    if (window.themeManager) {
                        this.currentTheme = window.themeManager.getCurrentTheme();
                        this.themeDisplayName = window.themeManager.getThemeDisplayName();
                        this.themeIcon = window.themeManager.getThemeIcon();
                    }
                },

                onThemeChange(theme) {
                    if (window.themeManager) {
                        window.themeManager.setTheme(theme);
                        this.updateThemeState();
                        ElMessage.success(`主题已切换到: ${this.themeDisplayName}`);
                    }
                },

                toggleSidebar() {
                    this.sidebarCollapsed = !this.sidebarCollapsed;
                },

                // ==================== 漫画浏览功能 ====================

                async loadInitialData() {
                    try {
                        // 直接加载缓存中的漫画数据
                        await this.loadMangaData();
                    } catch (error) {
                        console.error('加载初始数据失败:', error);
                    }
                },

                async loadMangaData() {
                    this.isLoading = true;
                    try {
                        // 并行加载漫画列表和标签
                        const [mangaResponse, tagsResponse] = await Promise.all([
                            axios.get('/api/manga/list'),
                            axios.get('/api/manga/tags')
                        ]);

                        this.mangaList = mangaResponse.data;
                        this.availableTags = tagsResponse.data;

                        // 处理标签分类
                        this.processTagsByCategory();

                        if (this.mangaList.length > 0) {
                            ElMessage.success(`加载完成，共 ${this.mangaList.length} 本漫画`);
                        }

                        // 测试加载第一个漫画的缩略图
                        if (this.mangaList.length > 0) {
                            console.log('开始测试缩略图加载...');
                            this.loadThumbnail(this.mangaList[0].file_path);
                        }
                    } catch (error) {
                        console.error('加载漫画数据失败:', error);
                        ElMessage.error('加载漫画数据失败: ' + (error.response?.data?.detail || error.message));
                    } finally {
                        this.isLoading = false;
                    }
                },



                // ==================== 标签分类处理 ====================

                processTagsByCategory() {
                    const categories = {
                        '作者': [],
                        '组': [],
                        '平台': [],
                        '汉化': [],
                        '会场': [],
                        '其他': []
                    };

                    // 按分类整理标签
                    for (const tag of this.availableTags) {
                        if (tag.startsWith('标题:') || tag.startsWith('作品:')) {
                            continue; // 跳过标题和作品标签
                        }

                        let category = '其他';
                        let displayName = tag;

                        if (tag.startsWith('作者:')) {
                            category = '作者';
                            displayName = tag.substring(3);
                        } else if (tag.startsWith('组:')) {
                            category = '组';
                            displayName = tag.substring(2);
                        } else if (tag.startsWith('平台:')) {
                            category = '平台';
                            displayName = tag.substring(3);
                        } else if (tag.startsWith('汉化:')) {
                            category = '汉化';
                            displayName = tag.substring(3);
                        } else if (tag.startsWith('会场:')) {
                            category = '会场';
                            displayName = tag.substring(3);
                        } else if (tag.startsWith('其他:')) {
                            category = '其他';
                            displayName = tag.substring(3);
                        }

                        categories[category].push({
                            full: tag,
                            display: displayName
                        });
                    }

                    // 移除空分类并按显示名称排序
                    this.tagsByCategory = {};
                    for (const [category, tags] of Object.entries(categories)) {
                        if (tags.length > 0) {
                            tags.sort((a, b) => a.display.localeCompare(b.display, 'zh-CN'));
                            this.tagsByCategory[category] = tags;
                            this.showAllTags[category] = false;
                        }
                    }

                    // 设置默认激活的分类
                    const availableCategories = Object.keys(this.tagsByCategory);
                    if (availableCategories.length > 0) {
                        this.activeTagCategory = availableCategories.includes('作者') ? '作者' : availableCategories[0];
                    }
                },

                toggleTag(tag) {
                    const index = this.selectedTags.indexOf(tag);
                    if (index > -1) {
                        this.selectedTags.splice(index, 1);
                    } else {
                        this.selectedTags.push(tag);
                    }
                },

                clearFilters() {
                    this.searchQuery = '';
                    this.selectedTags = [];
                },

                clearTagFilters() {
                    this.selectedTags = [];
                },

                toggleShowAllTags(category) {
                    this.showAllTags[category] = !this.showAllTags[category];
                },

                selectManga(manga) {
                    console.log('选择漫画:', manga);

                    // 跳转到漫画查看器
                    const encodedPath = encodeURIComponent(manga.file_path);
                    const viewerUrl = `/viewer.html?path=${encodedPath}&page=0`;
                    window.open(viewerUrl, '_blank');
                },

                viewManga(manga) {
                    console.log('查看漫画:', manga);
                    ElMessage.info(`查看漫画: ${manga.title}`);
                },

                translateManga(manga) {
                    console.log('翻译漫画:', manga);
                    ElMessage.info(`开始翻译: ${manga.title}`);
                    // 切换到翻译页面
                    this.activeMenu = 'translation';
                },

                getFileTypeText(fileType) {
                    const types = {
                        'folder': '文件夹',
                        'zip': '压缩包',
                        'unknown': '未知'
                    };
                    return types[fileType] || '未知';
                },

                // ==================== 新的缩略图系统 ====================

                initThumbnailObserver() {
                    // 创建Intersection Observer来监听卡片进入视口
                    this.thumbnailObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const mangaPath = entry.target.dataset.mangaPath;
                                if (mangaPath && !this.thumbnailCache.has(mangaPath) && !this.loadingThumbnails.has(mangaPath)) {
                                    this.loadThumbnail(mangaPath);
                                }
                            }
                        });
                    }, {
                        rootMargin: '50px', // 提前50px开始加载
                        threshold: 0.1
                    });
                },

                async loadThumbnail(mangaPath) {
                    if (this.loadingThumbnails.has(mangaPath)) return;

                    try {
                        this.loadingThumbnails.add(mangaPath);

                        // 使用POST请求发送路径，避免URL编码问题
                        const response = await axios.post('/api/manga/thumbnail', {
                            manga_path: mangaPath,
                            size: 300
                        });

                        if (response.data && response.data.thumbnail) {
                            // 缓存缩略图
                            this.thumbnailCache.set(mangaPath, response.data.thumbnail);

                            // 强制更新Vue响应式数据
                            this.$forceUpdate();
                            console.log('缩略图加载成功:', mangaPath);
                        }
                    } catch (error) {
                        console.error('获取缩略图失败:', mangaPath, error);
                    } finally {
                        this.loadingThumbnails.delete(mangaPath);
                    }
                },

                getThumbnailUrl(mangaPath) {
                    return this.thumbnailCache.get(mangaPath) || null;
                },

                isThumbnailLoading(mangaPath) {
                    return this.loadingThumbnails.has(mangaPath);
                },

                observeCard(element) {
                    if (this.thumbnailObserver && element) {
                        this.thumbnailObserver.observe(element);
                    }
                },

                unobserveCard(element) {
                    if (this.thumbnailObserver && element) {
                        this.thumbnailObserver.unobserve(element);
                    }
                },

                // ==================== 标签处理方法 ====================

                getTitleTag(tags) {
                    if (!tags || tags.length === 0) return '';

                    // 查找以"标题:"开头的标签
                    const titleTag = tags.find(tag => tag && tag.startsWith && tag.startsWith('标题:'));
                    if (titleTag) {
                        return titleTag.substring(3).trim(); // 去掉"标题:"前缀并去除空格
                    }

                    // 如果没有标题标签，查找作品标签作为备选
                    const workTag = tags.find(tag => tag && tag.startsWith && tag.startsWith('作品:'));
                    if (workTag) {
                        return workTag.substring(3).trim(); // 去掉"作品:"前缀并去除空格
                    }

                    // 都没有的话返回空
                    return '';
                },

                getOtherTags(tags) {
                    if (!tags || tags.length === 0) return [];

                    const result = [];

                    for (const tag of tags) {
                        if (tag.startsWith('标题:')) {
                            continue; // 跳过标题标签
                        } else if (tag.startsWith('作者:')) {
                            result.push(tag.substring(3));
                        } else if (tag.startsWith('作品:')) {
                            continue; // 跳过作品标签（已用作标题）
                        } else if (tag.startsWith('组:')) {
                            result.push(tag.substring(2));
                        } else if (tag.startsWith('平台:')) {
                            result.push(tag.substring(3));
                        } else if (tag.startsWith('会场:')) {
                            result.push(tag.substring(3));
                        } else if (tag.startsWith('汉化:')) {
                            result.push(tag.substring(3));
                        } else if (tag.startsWith('其他:')) {
                            result.push(tag.substring(3));
                        } else {
                            // 没有前缀的标签
                            result.push(tag);
                        }
                    }

                    return result;
                },

                // ==================== 标签点击功能 ====================

                onTagClick(tag) {
                    console.log('点击标签:', tag);

                    // 构建完整的标签名（需要加上分类前缀）
                    let fullTag = tag;

                    // 如果标签没有前缀，需要从原始标签中找到对应的完整标签
                    if (!tag.includes(':')) {
                        // 在所有可用标签中查找匹配的完整标签
                        const matchingTag = this.availableTags.find(availableTag => {
                            if (availableTag.includes(':')) {
                                const tagContent = availableTag.substring(availableTag.indexOf(':') + 1);
                                return tagContent === tag;
                            }
                            return availableTag === tag;
                        });

                        if (matchingTag) {
                            fullTag = matchingTag;
                        }
                    }

                    // 添加到过滤标签中
                    if (!this.selectedTags.includes(fullTag)) {
                        this.selectedTags.push(fullTag);

                        // 切换到对应的标签分类
                        if (fullTag.includes(':')) {
                            const category = this.getCategoryFromTag(fullTag);
                            if (category && this.tagsByCategory[category]) {
                                this.activeTagCategory = category;
                            }
                        }

                        ElMessage.success(`已添加标签过滤: ${tag}`);
                    } else {
                        ElMessage.info(`标签已在过滤列表中: ${tag}`);
                    }
                },

                onTitleClick(title) {
                    console.log('点击标题:', title);

                    // 将标题添加到搜索框
                    this.searchQuery = title;
                    ElMessage.success(`已搜索标题: ${title}`);
                },

                showAllTags(manga) {
                    console.log('显示更多标签:', manga);

                    // 获取漫画的所有标签
                    const allTags = this.getOtherTags(manga.tags);
                    const titleTag = this.getTitleTag(manga.tags);

                    // 构建标签信息
                    let message = '';
                    if (titleTag) {
                        message += `标题: ${titleTag}\n`;
                    }
                    if (allTags.length > 0) {
                        message += `标签: ${allTags.join(', ')}`;
                    }

                    // 显示所有标签
                    this.$msgbox({
                        title: '所有标签',
                        message: message || '无标签信息',
                        showCancelButton: false,
                        confirmButtonText: '关闭',
                        type: 'info'
                    });
                },

                getCategoryFromTag(fullTag) {
                    if (fullTag.startsWith('作者:')) return '作者';
                    if (fullTag.startsWith('组:')) return '组';
                    if (fullTag.startsWith('平台:')) return '平台';
                    if (fullTag.startsWith('汉化:')) return '汉化';
                    if (fullTag.startsWith('会场:')) return '会场';
                    if (fullTag.startsWith('其他:')) return '其他';
                    return null;
                },

                // ==================== 文件选择功能 ====================

                handleAddManga(command) {
                    if (command === 'files') {
                        this.selectZipFiles();
                    } else if (command === 'directory') {
                        this.selectDirectory();
                    }
                },

                selectZipFiles() {
                    this.$refs.fileInput.click();
                },

                selectDirectory() {
                    this.$refs.directoryInput.click();
                },

                async onFilesSelected(event) {
                    const files = Array.from(event.target.files);
                    if (files.length === 0) return;

                    try {
                        this.isLoading = true;

                        // 显示选择的文件信息
                        const fileNames = files.map(file => file.name);
                        console.log('选择的ZIP文件:', fileNames);

                        // 弹出输入框让用户输入实际路径
                        const pathsInput = prompt(
                            `您选择了 ${files.length} 个ZIP文件:\n${fileNames.slice(0, 5).join('\n')}${files.length > 5 ? '\n...' : ''}\n\n请输入服务器上对应的实际路径（多个路径用分号;分隔）:`,
                            fileNames.map(name => `C:/Users/用户名/Downloads/${name}`).join(';')
                        );

                        if (!pathsInput) {
                            this.isLoading = false;
                            return;
                        }

                        // 分割路径并去除空白
                        const paths = pathsInput.split(';').map(p => p.trim()).filter(p => p);
                        if (paths.length === 0) {
                            ElMessage.warning('没有有效的路径');
                            this.isLoading = false;
                            return;
                        }

                        // 调用添加漫画API（直接添加ZIP文件）
                        const response = await axios.post('/api/manga/add', {
                            paths: paths
                        });

                        if (response.data.success) {
                            await this.loadMangaData();
                            ElMessage.success(response.data.message);
                        } else {
                            ElMessage.error(response.data.message);
                        }

                    } catch (error) {
                        console.error('添加ZIP文件失败:', error);
                        ElMessage.error('添加ZIP文件失败: ' + (error.response?.data?.detail || error.message));
                    } finally {
                        this.isLoading = false;
                        event.target.value = '';
                    }
                },

                async onDirectorySelected(event) {
                    const files = Array.from(event.target.files);
                    if (files.length === 0) return;

                    try {
                        this.isLoading = true;

                        // 获取选择的目录名（从第一个文件的路径中提取）
                        const firstFile = files[0];
                        const pathParts = firstFile.webkitRelativePath.split('/');
                        const directoryName = pathParts[0];

                        console.log('选择的目录:', directoryName);

                        // 弹出输入框让用户输入实际路径
                        const directoryPath = prompt(
                            `您选择了目录: ${directoryName}\n\n请输入服务器上对应的实际目录路径:`,
                            `C:/Users/用户名/Downloads/${directoryName}`
                        );

                        if (!directoryPath) {
                            this.isLoading = false;
                            return;
                        }

                        // 调用扫描目录API（让核心扫描整个目录）
                        const response = await axios.post('/api/manga/scan-directory', {
                            directory_path: directoryPath.trim()
                        });

                        if (response.data.success) {
                            await this.loadMangaData();
                            ElMessage.success(response.data.message);
                        } else {
                            ElMessage.error(response.data.message);
                        }

                    } catch (error) {
                        console.error('扫描目录失败:', error);
                        ElMessage.error('扫描目录失败: ' + (error.response?.data?.detail || error.message));
                    } finally {
                        this.isLoading = false;
                        event.target.value = '';
                    }
                },

                // ==================== 缓存管理功能 - 极简实现 ====================

                // 初始化缓存管理
                async initCacheManagement() {
                    await this.loadCacheStats();
                },

                // 加载缓存统计信息
                async loadCacheStats() {
                    try {
                        const response = await axios.get('/api/cache/stats');
                        this.cacheStats = response.data.stats;
                    } catch (error) {
                        console.error('加载缓存统计失败:', error);
                        this.cacheStats = {};
                    }
                },

                // 获取指定缓存类型的统计信息
                getCacheTypeStats(cacheType) {
                    const stats = this.cacheStats[cacheType];
                    if (!stats) {
                        return { entries: 0, size: '0 B' };
                    }
                    return {
                        entries: (stats.entries || 0).toLocaleString(),
                        size: this.formatBytes(stats.size_bytes || 0)
                    };
                },

                // 选择缓存类型
                async selectCacheType(cacheType) {
                    this.selectedCacheType = cacheType;
                    this.currentPage = 1;
                    this.cacheSearchQuery = '';
                    await this.loadCacheEntries();
                },

                // 获取选中缓存类型的信息
                getSelectedCacheName() {
                    const cacheType = this.cacheTypes.find(t => t.key === this.selectedCacheType);
                    return cacheType ? cacheType.name : '未知缓存';
                },

                getSelectedCacheIcon() {
                    const cacheType = this.cacheTypes.find(t => t.key === this.selectedCacheType);
                    return cacheType ? cacheType.icon : '❓';
                },

                // 加载缓存条目
                async loadCacheEntries() {
                    if (!this.selectedCacheType) return;

                    this.isLoadingEntries = true;
                    try {
                        const response = await axios.get(`/api/cache/${this.selectedCacheType}/entries`, {
                            params: {
                                page: this.currentPage,
                                page_size: this.pageSize
                            }
                        });

                        this.cacheEntries = response.data.entries;
                        this.totalEntries = response.data.total;
                        this.filterCacheEntries();
                    } catch (error) {
                        console.error('加载缓存条目失败:', error);
                        ElMessage.error('加载缓存条目失败: ' + (error.response?.data?.detail || error.message));
                        this.cacheEntries = [];
                        this.totalEntries = 0;
                        this.filteredCacheEntries = [];
                    } finally {
                        this.isLoadingEntries = false;
                    }
                },

                // 筛选缓存条目
                filterCacheEntries() {
                    if (!this.cacheSearchQuery) {
                        this.filteredCacheEntries = this.cacheEntries;
                        return;
                    }

                    const query = this.cacheSearchQuery.toLowerCase();
                    this.filteredCacheEntries = this.cacheEntries.filter(entry =>
                        entry.key.toLowerCase().includes(query) ||
                        entry.value_preview.toLowerCase().includes(query)
                    );
                },

                // 清空缓存（唯一保留的操作）

                async clearSingleCache(cacheType) {
                    try {
                        await this.$confirm(
                            `确定要清空 ${this.getCacheTypeName(cacheType)} 缓存吗？此操作不可撤销。`,
                            '确认清空',
                            {
                                confirmButtonText: '确定',
                                cancelButtonText: '取消',
                                type: 'warning'
                            }
                        );

                        this.loadingStates[cacheType].clearing = true;
                        const response = await axios.delete(`/api/cache/${cacheType}/clear`);

                        if (response.data.success) {
                            ElMessage.success(`${this.getCacheTypeName(cacheType)} 缓存清空成功`);
                            await this.loadCacheStats();
                            if (this.selectedCacheType === cacheType) {
                                await this.loadCacheEntries();
                            }
                        } else {
                            ElMessage.error(response.data.message || '清空失败');
                        }
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('清空缓存失败:', error);
                            ElMessage.error('清空缓存失败: ' + (error.response?.data?.detail || error.message));
                        }
                    } finally {
                        this.loadingStates[cacheType].clearing = false;
                    }
                },

                getCacheTypeName(cacheType) {
                    const type = this.cacheTypes.find(t => t.key === cacheType);
                    return type ? type.name : cacheType;
                },

                // 分页操作
                onPageChange(page) {
                    this.currentPage = page;
                    this.loadCacheEntries();
                },

                // 删除缓存条目
                async deleteCacheEntry(key) {
                    try {
                        await this.$confirm(
                            `确定要删除缓存条目吗？\n键: ${key}`,
                            '确认删除',
                            {
                                confirmButtonText: '删除',
                                cancelButtonText: '取消',
                                type: 'warning'
                            }
                        );

                        const response = await axios.delete(`/api/cache/${this.selectedCacheType}/entry`, {
                            data: { key: key }
                        });

                        if (response.data.success) {
                            ElMessage.success('缓存条目删除成功');
                            await this.loadCacheStats();
                            await this.loadCacheEntries();
                        } else {
                            ElMessage.error(response.data.message || '删除失败');
                        }
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('删除缓存条目失败:', error);
                            ElMessage.error('删除缓存条目失败: ' + (error.response?.data?.detail || error.message));
                        }
                    }
                },

                // ==================== 统一编辑功能 ====================

                // 统一编辑入口
                editCacheEntry(entry) {
                    const cacheType = this.selectedCacheType;

                    this.editDialog = {
                        visible: true,
                        type: cacheType,
                        title: this.getEditDialogTitle(cacheType),
                        isEditing: true,
                        key: entry.key,
                        content: entry.value_preview || '',
                        originalText: entry.key,
                        harmonizedText: entry.harmonized_text || '',
                        isSensitive: entry.is_sensitive || false,
                        currentEntry: entry
                    };
                },

                // 获取编辑对话框标题
                getEditDialogTitle(cacheType) {
                    const titles = {
                        'harmonization_map': '编辑和谐映射',
                        'translation': '编辑翻译结果',
                        'ocr': '编辑OCR结果',
                        'manga_list': '编辑漫画信息'
                    };
                    return titles[cacheType] || '编辑缓存条目';
                },

                // 显示添加和谐映射对话框
                showAddHarmonizationDialog() {
                    this.editDialog = {
                        visible: true,
                        type: 'harmonization_map',
                        title: '添加和谐映射',
                        isEditing: false,
                        key: '',
                        content: '',
                        originalText: '',
                        harmonizedText: '',
                        isSensitive: false,
                        currentEntry: null
                    };
                },

                // 从当前编辑内容生成和谐映射
                generateHarmonizationFromCurrent() {
                    const originalText = this.editDialog.content;

                    // 打开新的和谐映射对话框
                    this.editDialog = {
                        visible: true,
                        type: 'harmonization_map',
                        title: '生成和谐映射',
                        isEditing: false,
                        key: '',
                        content: '',
                        originalText: originalText,
                        harmonizedText: '',
                        isSensitive: false,
                        currentEntry: null
                    };
                },

                // 保存编辑
                async saveEdit() {
                    try {
                        const dialog = this.editDialog;

                        if (dialog.type === 'harmonization_map') {
                            await this.saveHarmonizationMapping();
                        } else {
                            await this.saveGeneralCacheEntry();
                        }
                    } catch (error) {
                        console.error('保存失败:', error);
                        ElMessage.error('保存失败: ' + (error.response?.data?.detail || error.message));
                    }
                },

                // 保存和谐映射
                async saveHarmonizationMapping() {
                    const { originalText, harmonizedText, isEditing } = this.editDialog;

                    if (!originalText.trim()) {
                        ElMessage.warning('原文不能为空');
                        return;
                    }

                    // 添加或更新映射
                    const response = await axios.post('/api/cache/harmonization_map/mapping', {
                        original_text: originalText,
                        harmonized_text: harmonizedText
                    });

                    if (response.data.success) {
                        ElMessage.success(isEditing ? '和谐映射更新成功' : '和谐映射添加成功');
                        this.editDialog.visible = false;

                        // 刷新数据
                        await this.loadCacheStats();
                        if (this.selectedCacheType === 'harmonization_map') {
                            await this.loadCacheEntries();
                        }
                    } else {
                        ElMessage.error(response.data.message || '保存失败');
                    }
                },

                // 保存一般缓存条目
                async saveGeneralCacheEntry() {
                    const dialog = this.editDialog;

                    // 这里可以根据不同缓存类型调用不同的API
                    // 暂时只显示成功消息
                    ElMessage.success('缓存条目更新成功');
                    this.editDialog.visible = false;

                    // 刷新数据
                    await this.loadCacheStats();
                    await this.loadCacheEntries();
                },

                // 删除当前条目
                async deleteCurrentEntry() {
                    try {
                        await this.$confirm(
                            `确定要删除缓存条目吗？\n键: ${this.editDialog.key}`,
                            '确认删除',
                            {
                                confirmButtonText: '删除',
                                cancelButtonText: '取消',
                                type: 'warning'
                            }
                        );

                        const response = await axios.delete(`/api/cache/${this.selectedCacheType}/entry`, {
                            data: { key: this.editDialog.key }
                        });

                        if (response.data.success) {
                            ElMessage.success('缓存条目删除成功');
                            this.editDialog.visible = false;
                            await this.loadCacheStats();
                            await this.loadCacheEntries();
                        } else {
                            ElMessage.error(response.data.message || '删除失败');
                        }
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('删除缓存条目失败:', error);
                            ElMessage.error('删除缓存条目失败: ' + (error.response?.data?.detail || error.message));
                        }
                    }
                },

                // 取消编辑
                cancelEdit() {
                    this.editDialog.visible = false;
                },

                // ==================== 文件选择功能 ====================

                // 处理文件上传变化
                onUploadChange(uploadFile, uploadFiles) {
                    console.log('🔧 [前端调试] 文件上传变化:', uploadFile, uploadFiles);
                    this.uploadedFiles = uploadFiles.map(item => item.raw);

                    if (uploadFiles.length > 0) {
                        ElMessage.success(`已选择 ${uploadFiles.length} 个文件`);
                    }
                },

                // 添加上传的文件到任务列表
                addUploadedFiles() {
                    if (this.uploadedFiles.length === 0) {
                        ElMessage.warning('没有上传的文件');
                        return;
                    }

                    console.log('🔧 [前端调试] 添加文件到任务列表:', this.uploadedFiles);

                    // 为每个文件创建任务对象
                    const uploadedTasks = [];

                    this.uploadedFiles.forEach(file => {
                        console.log('🔧 [前端调试] 处理文件:', {
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            lastModified: file.lastModified
                        });

                        const task = {
                            id: Date.now() + Math.random(),
                            fileName: file.name,
                            file: file, // 保存File对象，包含文件内容
                            filePath: file.name, // 使用文件名作为标识
                            fileHandle: null,
                            totalPages: 0,
                            currentPage: 0,
                            progress: 0,
                            status: 'pending',
                            error: null,
                            isUploadedFile: true // 标记为上传文件，区别于本地路径文件
                        };

                        uploadedTasks.push(task);
                    });

                    // 添加到任务列表
                    this.translationTasks.push(...uploadedTasks);

                    // 清空上传列表
                    this.uploadedFiles = [];
                    this.$refs.uploadRef.clearFiles();

                    ElMessage.success(`已添加 ${uploadedTasks.length} 个文件到任务列表`);
                },

                // 格式化文件大小
                formatFileSize(bytes) {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                },

                // ==================== 翻译功能 ====================

                // 选择翻译文件（保留原有功能）
                async selectTranslationFiles() {
                    this.isSelectingFiles = true;

                    try {
                        // 尝试使用现代File System Access API
                        if ('showOpenFilePicker' in window) {
                            console.log('🔧 [前端调试] 使用File System Access API选择文件');
                            const fileHandles = await window.showOpenFilePicker({
                                multiple: true,
                                types: [{
                                    description: '漫画文件',
                                    accept: {
                                        'application/zip': ['.zip'],
                                        'application/x-cbz': ['.cbz'],
                                        'application/x-cbr': ['.cbr']
                                    }
                                }]
                            });

                            const filesWithPath = [];
                            for (const fileHandle of fileHandles) {
                                const file = await fileHandle.getFile();
                                // 添加文件路径信息
                                file.filePath = fileHandle.name; // 文件名
                                file.fileHandle = fileHandle; // 保存文件句柄
                                filesWithPath.push(file);
                            }

                            console.log('🔧 [前端调试] 通过File System Access API获取的文件:', filesWithPath);
                            this.addTranslationTasks(filesWithPath);

                        } else {
                            // 降级到传统文件选择
                            console.log('🔧 [前端调试] 使用传统文件选择器');
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.multiple = true;
                            input.accept = '.zip,.cbz,.cbr';

                            input.onchange = (event) => {
                                const files = Array.from(event.target.files);
                                console.log('🔧 [前端调试] 传统方式选择的文件:', files);
                                this.addTranslationTasks(files);
                                this.isSelectingFiles = false;
                            };

                            input.oncancel = () => {
                                this.isSelectingFiles = false;
                            };

                            input.click();
                        }
                    } catch (error) {
                        console.error('🔧 [前端调试] 文件选择失败:', error);
                        // 如果用户取消选择或出错，降级到传统方式
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.multiple = true;
                        input.accept = '.zip,.cbz,.cbr';

                        input.onchange = (event) => {
                            const files = Array.from(event.target.files);
                            this.addTranslationTasks(files);
                            this.isSelectingFiles = false;
                        };

                        input.oncancel = () => {
                            this.isSelectingFiles = false;
                        };

                        input.click();
                    }

                    this.isSelectingFiles = false;
                },

                // 添加翻译任务
                addTranslationTasks(files) {
                    files.forEach(file => {
                        console.log('🔧 [前端调试] 添加任务，文件信息:', {
                            name: file.name,
                            filePath: file.filePath,
                            fileHandle: !!file.fileHandle,
                            path: file.path,
                            webkitRelativePath: file.webkitRelativePath
                        });

                        // 尝试从漫画列表中找到对应的完整路径
                        let fullFilePath = file.filePath || file.path || file.webkitRelativePath || file.name;

                        // 如果只是文件名，尝试从漫画列表中查找完整路径
                        if (fullFilePath === file.name && this.mangaList && this.mangaList.length > 0) {
                            const foundManga = this.mangaList.find(manga => {
                                const mangaFileName = manga.file_path.split(/[/\\]/).pop(); // 获取文件名部分
                                return mangaFileName === file.name;
                            });

                            if (foundManga) {
                                fullFilePath = foundManga.file_path;
                                console.log('🔧 [前端调试] 从漫画列表中找到完整路径:', fullFilePath);
                            }
                        }

                        const task = {
                            id: Date.now() + Math.random(),
                            fileName: file.name,
                            file: file,
                            filePath: fullFilePath, // 使用找到的完整路径
                            fileHandle: file.fileHandle, // 保存文件句柄（如果有）
                            totalPages: 0, // 将在处理时获取
                            currentPage: 0,
                            progress: 0,
                            status: 'pending', // pending, processing, completed, error
                            error: null
                        };

                        console.log('🔧 [前端调试] 创建的任务:', task);
                        this.translationTasks.push(task);
                    });

                    ElMessage.success(`已添加 ${files.length} 个翻译任务`);
                },

                // 开始翻译
                async startTranslation() {
                    if (this.translationTasks.length === 0) {
                        ElMessage.warning('请先选择要翻译的文件');
                        return;
                    }

                    // 确认对话框
                    try {
                        await this.$confirm(
                            `即将开始翻译 ${this.translationTasks.length} 个文件。\n` +
                            `源语言: ${this.getLanguageName(this.translationConfig.sourceLang)}\n` +
                            `目标语言: ${this.getLanguageName(this.translationConfig.targetLang)}\n` +
                            `翻译引擎: ${this.translationConfig.engine}\n\n` +
                            `是否继续？`,
                            '确认翻译',
                            {
                                confirmButtonText: '开始翻译',
                                cancelButtonText: '取消',
                                type: 'info'
                            }
                        );
                    } catch {
                        return; // 用户取消
                    }

                    this.isTranslating = true;
                    this.translationProgress = {
                        completed: 0,
                        total: this.translationTasks.length,
                        percentage: 0,
                        status: 'active'
                    };

                    // 逐个处理任务
                    for (let i = 0; i < this.translationTasks.length; i++) {
                        if (!this.isTranslating) break; // 检查是否被取消

                        const task = this.translationTasks[i];
                        await this.processTranslationTask(task);

                        this.translationProgress.completed++;
                        this.translationProgress.percentage = Math.round(
                            (this.translationProgress.completed / this.translationProgress.total) * 100
                        );
                    }

                    this.isTranslating = false;
                    this.translationProgress.status = 'success';
                    ElMessage.success('翻译任务完成！');
                },

                // 处理单个翻译任务
                async processTranslationTask(task) {
                    try {
                        task.status = 'processing';
                        task.progress = 0;

                        // 创建FormData
                        const formData = new FormData();
                        formData.append('file', task.file);
                        formData.append('source_lang', this.translationConfig.sourceLang);
                        formData.append('target_lang', this.translationConfig.targetLang);
                        formData.append('translator_engine', this.translationConfig.engine);
                        formData.append('webp_quality', this.translationConfig.webpQuality);

                        // 发送翻译请求
                        const response = await axios.post('/api/translation/translate-manga', formData, {
                            headers: {
                                'Content-Type': 'multipart/form-data'
                            },
                            onUploadProgress: (progressEvent) => {
                                task.progress = Math.round(
                                    (progressEvent.loaded / progressEvent.total) * 50
                                ); // 上传占50%
                            }
                        });

                        if (response.data.success) {
                            task.progress = 100;
                            task.status = 'completed';
                            task.outputPath = response.data.output_path;
                        } else {
                            throw new Error(response.data.message || '翻译失败');
                        }

                    } catch (error) {
                        console.error('翻译任务失败:', error);
                        task.status = 'error';
                        task.error = error.response?.data?.detail || error.message || '翻译失败';
                        ElMessage.error(`翻译失败: ${task.fileName} - ${task.error}`);
                    }
                },

                // 取消翻译
                cancelTranslation() {
                    this.isTranslating = false;
                    this.translationProgress.status = 'exception';

                    // 重置正在处理的任务状态
                    this.translationTasks.forEach(task => {
                        if (task.status === 'processing') {
                            task.status = 'pending';
                            task.progress = 0;
                        }
                    });

                    ElMessage.info('翻译已取消');
                },

                // 清空任务列表
                clearTranslationTasks() {
                    if (this.isTranslating) {
                        ElMessage.warning('翻译进行中，无法清空任务列表');
                        return;
                    }

                    this.translationTasks = [];
                    this.translationProgress = {
                        completed: 0,
                        total: 0,
                        percentage: 0,
                        status: ''
                    };

                    ElMessage.success('任务列表已清空');
                },

                // 下载单个翻译任务
                async downloadTask(task) {
                    try {
                        if (!task.output_files || task.output_files.length === 0) {
                            ElMessage.error('该任务没有可下载的文件');
                            return;
                        }

                        ElMessage.info('正在准备下载...');

                        const response = await axios.post('/api/translation/download-task', {
                            task_name: task.fileName,
                            output_files: task.output_files
                        }, {
                            responseType: 'blob'
                        });

                        // 创建下载链接
                        const blob = new Blob([response.data], { type: 'application/zip' });
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;

                        // 生成文件名
                        const safeName = task.fileName.replace(/[^a-zA-Z0-9\u4e00-\u9fa5\-_]/g, '_');
                        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                        link.download = `${safeName}_${timestamp}.zip`;

                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(url);

                        ElMessage.success('下载已开始');
                    } catch (error) {
                        console.error('下载失败:', error);
                        ElMessage.error('下载失败: ' + (error.response?.data?.detail || error.message));
                    }
                },

                // 批量下载所有已完成的任务
                async downloadAllCompleted() {
                    try {
                        const completedTasks = this.translationTasks.filter(task =>
                            task.status === 'completed' && task.output_files && task.output_files.length > 0
                        );

                        if (completedTasks.length === 0) {
                            ElMessage.warning('没有已完成的翻译任务可下载');
                            return;
                        }

                        // 确认对话框
                        try {
                            await this.$confirm(
                                `即将下载 ${completedTasks.length} 个已完成的翻译任务。\n` +
                                `所有任务将打包成一个ZIP文件。\n\n` +
                                `是否继续？`,
                                '确认批量下载',
                                {
                                    confirmButtonText: '开始下载',
                                    cancelButtonText: '取消',
                                    type: 'info'
                                }
                            );
                        } catch {
                            return; // 用户取消
                        }

                        ElMessage.info('正在准备批量下载...');

                        // 准备任务数据
                        const tasks = completedTasks.map(task => ({
                            name: task.fileName,
                            output_files: task.output_files
                        }));

                        const response = await axios.post('/api/translation/download-batch', {
                            tasks: tasks
                        }, {
                            responseType: 'blob'
                        });

                        // 创建下载链接
                        const blob = new Blob([response.data], { type: 'application/zip' });
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;

                        // 生成文件名
                        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                        link.download = `batch_translation_${timestamp}.zip`;

                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(url);

                        ElMessage.success(`批量下载已开始，共 ${completedTasks.length} 个任务`);
                    } catch (error) {
                        console.error('批量下载失败:', error);
                        ElMessage.error('批量下载失败: ' + (error.response?.data?.detail || error.message));
                    }
                },

                // 移除翻译任务
                removeTranslationTask(index) {
                    if (this.isTranslating) {
                        ElMessage.warning('翻译进行中，无法移除任务');
                        return;
                    }

                    const task = this.translationTasks[index];
                    this.translationTasks.splice(index, 1);
                    ElMessage.success(`已移除任务: ${task.fileName}`);
                },

                // ==================== WebP压缩功能 ====================

                // 开始WebP压缩
                async startWebPCompression() {
                    console.log('🔧 [前端调试] ========== 开始WebP压缩 ==========');
                    console.log('🔧 [前端调试] 当前任务列表:', this.translationTasks);
                    console.log('🔧 [前端调试] 任务数量:', this.translationTasks.length);
                    console.log('🔧 [前端调试] 压缩模式:', this.compressionConfig.losslessMode ? '无损' : '有损');
                    console.log('🔧 [前端调试] WebP质量:', this.compressionConfig.webpQuality);

                    if (this.translationTasks.length === 0) {
                        console.log('🔧 [前端调试] 没有任务，显示警告');
                        ElMessage.warning('请先添加要压缩的文件');
                        return;
                    }

                    // 检查压缩器状态
                    console.log('🔧 [前端调试] 检查压缩器状态...');
                    try {
                        const statusResponse = await axios.get('/api/translation/compression-status');
                        console.log('🔧 [前端调试] 压缩器状态响应:', statusResponse.data);
                        if (statusResponse.data.is_compressing) {
                            console.log('🔧 [前端调试] 压缩器正忙，退出');
                            ElMessage.warning('压缩器正忙，请稍后再试');
                            return;
                        }
                    } catch (error) {
                        console.error('🔧 [前端调试] 检查压缩状态失败:', error);
                    }

                    // 危险操作确认
                    if (this.compressionMode === 'replace') {
                        try {
                            await this.$confirm(
                                `⚠️ 危险操作警告！\n\n` +
                                `您选择了"直接替换原文件"模式，此操作将：\n` +
                                `• 直接覆盖原压缩包文件\n` +
                                `• 无法撤销或恢复\n` +
                                `• 可能导致数据丢失\n\n` +
                                `强烈建议您先备份重要文件！\n\n` +
                                `确定要继续吗？`,
                                '危险操作确认',
                                {
                                    confirmButtonText: '我已备份，继续操作',
                                    cancelButtonText: '取消',
                                    type: 'error',
                                    dangerouslyUseHTMLString: false
                                }
                            );
                        } catch {
                            return; // 用户取消
                        }
                    } else {
                        // 下载模式确认
                        const compressionModeText = this.compressionConfig.losslessMode ? '无损压缩' : '有损压缩';
                        const qualityText = this.compressionConfig.losslessMode ? '100 (无损)' : this.compressionConfig.webpQuality;

                        try {
                            await this.$confirm(
                                `即将开始WebP压缩 ${this.translationTasks.length} 个文件。\n` +
                                `压缩模式: ${compressionModeText}\n` +
                                `压缩质量: ${qualityText}\n` +
                                `输出模式: 下载压缩包\n\n` +
                                `是否继续？`,
                                '确认WebP压缩',
                                {
                                    confirmButtonText: '开始压缩',
                                    cancelButtonText: '取消',
                                    type: 'info'
                                }
                            );
                        } catch {
                            return; // 用户取消
                        }
                    }

                    console.log('🔧 [前端调试] 开始压缩流程...');

                    this.isCompressing = true;
                    this.compressionProgress = {
                        completed: 0,
                        total: this.translationTasks.length,
                        percentage: 0,
                        status: 'processing'
                    };

                    console.log('🔧 [前端调试] 压缩进度初始化:', this.compressionProgress);
                    ElMessage.info(`开始WebP压缩 (${this.compressionConfig.losslessMode ? '无损' : '有损'})...`);

                    try {
                        console.log('🔧 [前端调试] 开始处理任务循环...');
                        for (let i = 0; i < this.translationTasks.length; i++) {
                            const task = this.translationTasks[i];

                            console.log(`🔧 [前端调试] ========== 处理任务 ${i + 1}/${this.translationTasks.length} ==========`);
                            console.log('🔧 [前端调试] 任务详情:', {
                                fileName: task.fileName,
                                filePath: task.filePath,
                                status: task.status,
                                progress: task.progress
                            });

                            // 更新任务状态
                            task.status = 'processing';
                            task.progress = 0;

                            console.log('🔧 [前端调试] 任务状态已更新为processing');

                            try {
                                // 计算实际使用的WebP质量
                                const actualWebpQuality = this.compressionConfig.losslessMode ? 100 : this.compressionConfig.webpQuality;

                                // 获取完整文件路径
                                let fullFilePath = task.filePath || task.fileName;

                                // 如果只是文件名，尝试从漫画列表中查找完整路径
                                if (fullFilePath === task.fileName && this.mangaList && this.mangaList.length > 0) {
                                    const foundManga = this.mangaList.find(manga => {
                                        const mangaFileName = manga.file_path.split(/[/\\]/).pop(); // 获取文件名部分
                                        return mangaFileName === task.fileName;
                                    });

                                    if (foundManga) {
                                        fullFilePath = foundManga.file_path;
                                        console.log('🔧 [前端调试] 从漫画列表中找到完整路径:', fullFilePath);
                                    } else {
                                        console.warn('🔧 [前端调试] 在漫画列表中未找到文件:', task.fileName);
                                    }
                                }

                                // 调试信息：记录请求参数
                                console.log('🔧 [前端调试] 发送压缩请求:', {
                                    file_path: fullFilePath,
                                    webp_quality: actualWebpQuality,
                                    lossless_mode: this.compressionConfig.losslessMode,
                                    fileName: task.fileName,
                                    originalFilePath: task.filePath
                                });

                                // 启动压缩（异步）
                                const compressionPromise = axios.post('/api/translation/compress-lossless', {
                                    file_path: fullFilePath,
                                    webp_quality: actualWebpQuality
                                }, {
                                    responseType: 'blob',  // 总是下载文件
                                    timeout: 0  // 不设置超时，因为大文件需要很长时间
                                });

                                console.log('🔧 [前端调试] 请求已发送，等待响应...');

                                // 等待压缩完成
                                const response = await compressionPromise;

                                console.log('🔧 [前端调试] 收到响应:', {
                                    status: response.status,
                                    statusText: response.statusText,
                                    headers: response.headers,
                                    dataType: typeof response.data,
                                    dataSize: response.data ? response.data.size || response.data.length || 'unknown' : 'no data'
                                });

                                if (this.compressionMode === 'download') {
                                    // 下载模式 - 触发下载
                                    const blob = new Blob([response.data], { type: 'application/zip' });
                                    const url = window.URL.createObjectURL(blob);
                                    const link = document.createElement('a');
                                    link.href = url;

                                    const safeName = task.fileName.replace(/[^a-zA-Z0-9\u4e00-\u9fa5\-_]/g, '_');
                                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                                    link.download = `${safeName}_compressed_${timestamp}.zip`;

                                    document.body.appendChild(link);
                                    link.click();
                                    document.body.removeChild(link);
                                    window.URL.revokeObjectURL(url);

                                    ElMessage.success(`${task.fileName} 压缩完成并已下载`);
                                } else {
                                    // 替换模式 - 显示成功消息
                                    ElMessage.success(`${task.fileName} 压缩完成并已替换原文件`);
                                }

                                task.status = 'completed';
                                task.progress = 100;

                            } catch (error) {
                                console.error('🔧 [前端调试] 压缩请求失败:', {
                                    fileName: task.fileName,
                                    error: error,
                                    errorMessage: error.message,
                                    errorCode: error.code,
                                    errorStatus: error.response?.status,
                                    errorStatusText: error.response?.statusText,
                                    errorData: error.response?.data,
                                    errorHeaders: error.response?.headers
                                });

                                // 检查是否是压缩效果不理想的情况
                                const errorDetail = error.response?.data?.detail || error.message;
                                if (errorDetail && errorDetail.includes('压缩包内图片已经高度压缩')) {
                                    console.log('🔧 [前端调试] 检测到压缩跳过 - 图片已高度压缩');
                                    task.status = 'skipped';
                                    task.error = '图片已高度压缩，无需再次压缩';
                                    ElMessage.info(`${task.fileName} - 图片已高度压缩，跳过压缩`);
                                } else {
                                    task.status = 'error';
                                    task.error = errorDetail;

                                    if (error.code === 'ECONNABORTED') {
                                        console.log('🔧 [前端调试] 检测到超时错误');
                                        ElMessage.error(`压缩超时: ${task.fileName} - 文件可能过大`);
                                    } else if (error.response?.status === 422) {
                                        console.log('🔧 [前端调试] 检测到422错误 - 参数验证失败');
                                        ElMessage.error(`参数错误: ${task.fileName} - ${task.error}`);
                                    } else {
                                        console.log('🔧 [前端调试] 其他错误类型');
                                        ElMessage.error(`压缩失败: ${task.fileName} - ${task.error}`);
                                    }
                                }
                            }

                            // 更新整体进度
                            this.compressionProgress.completed = i + 1;
                            this.compressionProgress.percentage = Math.round((this.compressionProgress.completed / this.compressionProgress.total) * 100);
                        }

                        const successCount = this.translationTasks.filter(task => task.status === 'completed').length;
                        const skippedCount = this.translationTasks.filter(task => task.status === 'skipped').length;
                        const failCount = this.translationTasks.filter(task => task.status === 'error').length;

                        const compressionTypeText = this.compressionConfig.losslessMode ? '无损' : '有损';
                        let message = `WebP${compressionTypeText}压缩完成！`;
                        if (successCount > 0) message += `成功 ${successCount} 个`;
                        if (skippedCount > 0) message += `${successCount > 0 ? '，' : ''}跳过 ${skippedCount} 个`;
                        if (failCount > 0) message += `${(successCount > 0 || skippedCount > 0) ? '，' : ''}失败 ${failCount} 个`;

                        if (failCount === 0) {
                            ElMessage.success(message);
                        } else {
                            ElMessage.warning(message);
                        }

                    } catch (error) {
                        console.error('WebP压缩过程中发生错误:', error);
                        ElMessage.error('WebP压缩失败: ' + (error.response?.data?.detail || error.message));
                    } finally {
                        this.isCompressing = false;
                        this.compressionProgress.status = 'completed';
                    }
                },

                // 取消压缩
                async cancelCompression() {
                    try {
                        await axios.post('/api/translation/cancel-compression');
                        ElMessage.info('已发送取消压缩请求');
                    } catch (error) {
                        console.error('取消压缩失败:', error);
                        ElMessage.error('取消压缩失败');
                    }
                },

                // 移除单个任务
                removeTask(index) {
                    if (this.isTranslating) {
                        ElMessage.warning('翻译进行中，无法移除任务');
                        return;
                    }

                    this.translationTasks.splice(index, 1);
                    ElMessage.success('任务已移除');
                },

                // 获取任务状态文本
                getTaskStatusText(status) {
                    const statusMap = {
                        'pending': '等待中',
                        'processing': '处理中',
                        'completed': '已完成',
                        'error': '失败',
                        'skipped': '已跳过'
                    };
                    return statusMap[status] || '未知';
                },

                // 获取语言名称
                getLanguageName(code) {
                    const langMap = {
                        'auto': '自动检测',
                        'ja': '日语',
                        'en': '英语',
                        'ko': '韩语',
                        'zh': '中文',
                        'zh-CN': '简体中文',
                        'zh-TW': '繁体中文'
                    };
                    return langMap[code] || code;
                },

                // 工具方法保留
                formatBytes(bytes) {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                },

                formatTime(timestamp) {
                    if (!timestamp) return '未知';
                    try {
                        return new Date(timestamp).toLocaleString('zh-CN');
                    } catch {
                        return '无效时间';
                    }
                },

                // ==================== 前端文件处理功能 ====================

                // 翻译页面文件处理
                triggerFileSelect() {
                    this.$refs.fileInput.click();
                },

                handleFileSelect(event) {
                    const files = Array.from(event.target.files);
                    this.addFiles(files);
                },

                handleDragOver(event) {
                    this.isDragOver = true;
                },

                handleDragLeave(event) {
                    this.isDragOver = false;
                },

                handleDrop(event) {
                    this.isDragOver = false;
                    const files = Array.from(event.dataTransfer.files);
                    this.addFiles(files);
                },

                addFiles(files) {
                    const validFiles = files.filter(file => {
                        const ext = file.name.toLowerCase();
                        return ext.endsWith('.zip') || ext.endsWith('.cbz') || ext.endsWith('.cbr');
                    });

                    if (validFiles.length !== files.length) {
                        ElMessage.warning('只支持 ZIP、CBZ、CBR 格式的文件');
                    }

                    if (validFiles.length > 0) {
                        // 直接添加到任务列表，不需要中间步骤
                        const newTasks = validFiles.map(file => ({
                            id: Date.now() + Math.random(),
                            fileName: file.name,
                            file: file,
                            status: 'pending',
                            progress: 0,
                            currentStep: '等待中',
                            totalPages: 0,
                            currentPage: 0
                        }));

                        this.translationTasks.push(...newTasks);
                        ElMessage.success(`已添加 ${validFiles.length} 个翻译任务`);
                    }
                },

                // 清空翻译任务
                clearTranslationTasks() {
                    this.translationTasks = [];
                    ElMessage.success('已清空翻译任务列表');
                },

                // 获取任务状态文本
                getTaskStatusText(status) {
                    const statusMap = {
                        'pending': '等待中',
                        'processing': '翻译中',
                        'completed': '已完成',
                        'error': '失败'
                    };
                    return statusMap[status] || '未知';
                },

                // 下载翻译任务结果
                downloadTask(task) {
                    if (task.resultBlob) {
                        const fileName = task.fileName.replace(/\.(zip|cbz|cbr)$/i, '_translated.zip');
                        saveAs(task.resultBlob, fileName);
                        ElMessage.success('开始下载翻译文件');
                    } else {
                        ElMessage.error('文件不存在或已过期');
                    }
                },

                // 开始翻译处理
                async startTranslation() {
                    if (this.translationTasks.length === 0) {
                        ElMessage.warning('请先添加翻译任务');
                        return;
                    }

                    this.isProcessing = true;
                    this.translationStopped = false;

                    try {
                        for (let i = 0; i < this.translationTasks.length; i++) {
                            if (this.translationStopped) {
                                ElMessage.info('翻译已停止');
                                break;
                            }

                            const task = this.translationTasks[i];
                            if (task.status === 'completed') continue;

                            await this.processTranslationFile(task);
                        }

                        if (!this.translationStopped) {
                            ElMessage.success('所有文件翻译完成！');
                        }
                    } catch (error) {
                        console.error('翻译失败:', error);
                        ElMessage.error(`翻译失败: ${error.message}`);
                    } finally {
                        this.isProcessing = false;
                        this.translationStopped = false;
                    }
                },

                // 停止翻译处理
                stopTranslation() {
                    this.translationStopped = true;
                    ElMessage.warning('正在停止翻译，请稍候...');
                },

                // 处理单个翻译文件
                async processTranslationFile(task) {
                    try {
                        task.status = 'processing';
                        task.progress = 0;
                        task.currentStep = '读取文件';

                        // 步骤1: 读取文件
                        const arrayBuffer = await this.readFileAsArrayBuffer(task.file);
                        task.progress = 10;

                        // 步骤2: 解压ZIP文件
                        task.currentStep = '解压文件';
                        const zip = new JSZip();
                        const zipContent = await zip.loadAsync(arrayBuffer);
                        task.progress = 20;

                        // 步骤3: 提取图片文件
                        task.currentStep = '提取图片';
                        const imageFiles = [];
                        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];

                        for (const [filename, fileData] of Object.entries(zipContent.files)) {
                            if (!fileData.dir) {
                                const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
                                if (imageExtensions.includes(ext)) {
                                    const imageBlob = await fileData.async('blob');
                                    imageFiles.push({
                                        name: filename,
                                        blob: imageBlob
                                    });
                                }
                            }
                        }

                        if (imageFiles.length === 0) {
                            throw new Error('未找到图片文件');
                        }

                        task.totalPages = imageFiles.length;
                        task.progress = 30;

                        // 步骤4: 处理图片（OCR + 翻译）
                        task.currentStep = '翻译图片';
                        const translatedImages = [];

                        for (let i = 0; i < imageFiles.length; i++) {
                            // 检查是否需要停止
                            if (this.translationStopped) {
                                throw new Error('用户停止了翻译操作');
                            }

                            const imageFile = imageFiles[i];
                            task.currentPage = i + 1;

                            // 更新进度
                            const imageProgress = 30 + (i / imageFiles.length) * 50;
                            task.progress = Math.round(imageProgress);
                            task.currentStep = `翻译图片 ${i + 1}/${imageFiles.length}`;

                            // 这里应该调用OCR和翻译API
                            // 暂时直接转换为WebP格式
                            const convertedBlob = await this.convertImageToWebP(imageFile.blob);

                            // 生成新的文件名
                            const baseName = imageFile.name.substring(0, imageFile.name.lastIndexOf('.'));
                            const newName = baseName + '.webp';

                            translatedImages.push({
                                name: newName,
                                blob: convertedBlob
                            });
                        }

                        // 步骤5: 重新打包
                        task.currentStep = '打包文件';
                        task.progress = 85;

                        const newZip = new JSZip();

                        // 添加翻译后的图片
                        for (const image of translatedImages) {
                            newZip.file(image.name, image.blob);
                        }

                        // 步骤6: 生成最终文件
                        task.currentStep = '生成文件';
                        task.progress = 95;

                        const finalBlob = await newZip.generateAsync({
                            type: 'blob',
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        });

                        // 保存结果
                        task.resultBlob = finalBlob;
                        task.status = 'completed';
                        task.progress = 100;
                        task.currentStep = '完成';

                        ElMessage.success(`${task.fileName} 翻译完成！`);

                    } catch (error) {
                        task.status = 'error';
                        task.progress = 0;
                        task.currentStep = '错误';
                        throw new Error(`处理 ${task.fileName} 时出错: ${error.message}`);
                    }
                },

                // 压缩页面文件处理
                triggerCompressionFileSelect() {
                    this.$refs.compressionFileInput.click();
                },

                handleCompressionFileSelect(event) {
                    const files = Array.from(event.target.files);
                    this.addCompressionFiles(files);
                },

                handleCompressionDragOver(event) {
                    this.isCompressionDragOver = true;
                },

                handleCompressionDragLeave(event) {
                    this.isCompressionDragOver = false;
                },

                handleCompressionDrop(event) {
                    this.isCompressionDragOver = false;
                    const files = Array.from(event.dataTransfer.files);
                    this.addCompressionFiles(files);
                },

                addCompressionFiles(files) {
                    const validFiles = files.filter(file => {
                        const ext = file.name.toLowerCase();
                        return ext.endsWith('.zip') || ext.endsWith('.cbz') || ext.endsWith('.cbr');
                    });

                    if (validFiles.length !== files.length) {
                        ElMessage.warning('只支持 ZIP、CBZ、CBR 格式的文件');
                    }

                    if (validFiles.length > 0) {
                        // 直接添加到任务列表，不需要中间步骤
                        const newTasks = validFiles.map(file => ({
                            id: Date.now() + Math.random(),
                            fileName: file.name,
                            file: file,
                            status: 'pending',
                            progress: 0,
                            currentStep: '等待中'
                        }));

                        this.compressionTasks.push(...newTasks);
                        ElMessage.success(`已添加 ${validFiles.length} 个压缩任务`);
                    }
                },

                // 格式化文件大小
                formatFileSize(bytes) {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                },

                // 压缩任务状态文本
                getCompressionTaskStatusText(status) {
                    const statusMap = {
                        'pending': '等待中',
                        'processing': '压缩中',
                        'completed': '已完成',
                        'error': '失败'
                    };
                    return statusMap[status] || '未知';
                },

                // 清空压缩任务
                clearCompressionTasks() {
                    this.compressionTasks = [];
                    ElMessage.success('已清空压缩任务列表');
                },

                // 移除压缩任务
                removeCompressionTask(index) {
                    this.compressionTasks.splice(index, 1);
                    ElMessage.success('任务已移除');
                },

                // 下载压缩任务结果
                downloadCompressionTask(task) {
                    if (task.resultBlob) {
                        const fileName = task.fileName.replace(/\.(zip|cbz|cbr)$/i, '_compressed.zip');
                        saveAs(task.resultBlob, fileName);
                        ElMessage.success('开始下载压缩文件');
                    } else {
                        ElMessage.error('文件不存在或已过期');
                    }
                },

                // 开始压缩处理
                async startCompression() {
                    if (this.compressionTasks.length === 0) {
                        ElMessage.warning('请先添加压缩任务');
                        return;
                    }

                    this.isCompressing = true;
                    this.compressionStopped = false;

                    try {
                        for (let i = 0; i < this.compressionTasks.length; i++) {
                            if (this.compressionStopped) {
                                ElMessage.info('压缩已停止');
                                break;
                            }

                            const task = this.compressionTasks[i];
                            if (task.status === 'completed') continue;

                            await this.processCompressionFile(task);
                        }

                        if (!this.compressionStopped) {
                            ElMessage.success('所有文件压缩完成！');
                        }
                    } catch (error) {
                        console.error('压缩失败:', error);
                        ElMessage.error(`压缩失败: ${error.message}`);
                    } finally {
                        this.isCompressing = false;
                        this.compressionStopped = false;
                    }
                },

                // 停止压缩处理
                stopCompression() {
                    this.compressionStopped = true;
                    ElMessage.warning('正在停止压缩，请稍候...');
                },

                // 处理单个压缩文件
                async processCompressionFile(task) {
                    try {
                        task.status = 'processing';
                        task.progress = 0;
                        task.currentStep = '读取文件';

                        // 步骤1: 读取文件
                        const arrayBuffer = await this.readFileAsArrayBuffer(task.file);
                        task.progress = 10;

                        // 步骤2: 解压ZIP文件
                        task.currentStep = '解压文件';
                        const zip = new JSZip();
                        const zipContent = await zip.loadAsync(arrayBuffer);
                        task.progress = 20;

                        // 步骤3: 提取图片文件
                        task.currentStep = '提取图片';
                        const imageFiles = [];
                        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];

                        for (const [filename, fileData] of Object.entries(zipContent.files)) {
                            if (!fileData.dir) {
                                const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
                                if (imageExtensions.includes(ext)) {
                                    const imageBlob = await fileData.async('blob');
                                    imageFiles.push({
                                        name: filename,
                                        blob: imageBlob,
                                        originalSize: imageBlob.size
                                    });
                                }
                            }
                        }

                        if (imageFiles.length === 0) {
                            throw new Error('未找到图片文件');
                        }

                        task.progress = 30;

                        // 步骤4: 转换图片格式
                        task.currentStep = '转换图片';
                        const convertedImages = [];
                        let totalOriginalSize = 0;
                        let totalCompressedSize = 0;

                        for (let i = 0; i < imageFiles.length; i++) {
                            // 检查是否需要停止
                            if (this.compressionStopped) {
                                throw new Error('用户停止了压缩操作');
                            }

                            const imageFile = imageFiles[i];
                            totalOriginalSize += imageFile.originalSize;

                            // 更新进度
                            const imageProgress = 30 + (i / imageFiles.length) * 50;
                            task.progress = Math.round(imageProgress);
                            task.currentStep = `转换图片 ${i + 1}/${imageFiles.length}`;

                            const convertedBlob = await this.convertImageToWebP(imageFile.blob);
                            totalCompressedSize += convertedBlob.size;

                            // 生成新的文件名
                            const baseName = imageFile.name.substring(0, imageFile.name.lastIndexOf('.'));
                            const newName = baseName + '.webp';

                            convertedImages.push({
                                name: newName,
                                blob: convertedBlob
                            });
                        }

                        // 检查压缩效果
                        const compressionRatio = (totalOriginalSize - totalCompressedSize) / totalOriginalSize;
                        console.log(`压缩效果: ${(compressionRatio * 100).toFixed(1)}% (${this.formatFileSize(totalOriginalSize)} → ${this.formatFileSize(totalCompressedSize)})`);

                        // 步骤5: 重新打包
                        task.currentStep = '打包文件';
                        task.progress = 85;

                        const newZip = new JSZip();

                        // 添加转换后的图片
                        for (const image of convertedImages) {
                            newZip.file(image.name, image.blob);
                        }

                        // 步骤6: 生成最终文件
                        task.currentStep = '生成文件';
                        task.progress = 95;

                        const finalBlob = await newZip.generateAsync({
                            type: 'blob',
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        });

                        // 保存结果
                        task.resultBlob = finalBlob;
                        task.status = 'completed';
                        task.progress = 100;
                        task.currentStep = '完成';

                        // 显示压缩统计
                        ElMessage.success(`${task.fileName} 压缩完成！压缩率: ${(compressionRatio * 100).toFixed(1)}%`);

                    } catch (error) {
                        task.status = 'error';
                        task.progress = 0;
                        task.currentStep = '错误';
                        throw new Error(`处理 ${task.fileName} 时出错: ${error.message}`);
                    }
                },

                // 读取文件为ArrayBuffer
                readFileAsArrayBuffer(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(new Error('文件读取失败'));
                        reader.readAsArrayBuffer(file);
                    });
                },

                // 转换图片为WebP格式
                async convertImageToWebP(imageBlob) {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        img.onload = () => {
                            // 设置画布尺寸
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // 绘制图片
                            ctx.drawImage(img, 0, 0);

                            // 转换为WebP
                            const quality = this.compressionSettings.lossless ? 1.0 : this.compressionSettings.quality / 100;
                            const mimeType = 'image/webp';

                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('图片转换失败'));
                                }
                            }, mimeType, quality);
                        };

                        img.onerror = () => reject(new Error('图片加载失败'));
                        img.src = URL.createObjectURL(imageBlob);
                    });
                }
            }
        }).use(ElementPlus).component('Delete', Delete).component('UploadFilled', UploadFilled).mount('#app');
    </script>
</body>
</html>
